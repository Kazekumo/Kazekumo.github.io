<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="目录 # Base Entity源码分析 开发中发现许多对象都依赖了css的基类对象BaseEntity 偶然点开发现里面的写法不太容易理解，因此分析记录一下 点开对象可以发现，有两个属性是比较特别的，也就是 propMap 和 visitor 本文的目的也主要是分析这两个对象的用途。 ![[/static/img/Pasted image 20230505092032.png]] 先直接看这两个对象在哪用了，翻阅源码可以发现，两个属性的主要使用入口都在toString中。 最终这个函数是调用了toString0 或者 hexString 初见这一坨，我也百思不得其解，先不管，继续看看toString0 ![[/static/img/Pasted image 20230505103131.png]] 分析代码可知，toString0这个方法才是对象转字符串的主要实现，通过getProps获取对象的属性列表，然后在下面进行属性的拼接 ![[/static/img/Pasted image 20230505103619.png]] 看看getProps，可以发现propMap的用途是存储该类的所有属性名称。 如果该对象的属性未初始化，则通过反射获取。 ![[/static/img/Pasted image 20230512180112.png]] 需要注意的是，这里使用了 double check lock，避免重入。 当第二次进入时，就可以复用属性，不用再反射获取了。 到了此处，propMap 的用途基本就解答了。 那么为啥要有 visotor 呢？我们再回过头来看toString方法 ![[/static/img/Pasted image 20230512173325.png]] 在toString方法中，visitor 的逻辑主要如下 如果 visitor为空，重新初始化 visitor 如果 visitor.get() 为空： 1. 设置 visitor 为当前对象 2. 调用 toString0 3. 设置 visitor 为 null 如果 visitor 的值不为空，返回 HexString 这里的目的不太好理解。首先对于步骤1，我们可以先忽略，因为实际不影响流程。 控制流程的主要是步骤2和步骤3。 首先可以观察到，步骤2的进入条件是 visitor 为空，步骤3的进入条件为 visitor 不为空。也就是说，步骤2和步骤3这两步操作是互斥的。 在步骤2."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://example.com/docs/Java/"><title>Java | Hugo Book</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.78166b9d46e23e0ea915cb6887a30b633e7bc4fad10c8b6b9f6fa532271c19ba.js integrity="sha256-eBZrnUbiPg6pFctoh6MLYz57xPrRDItrn2+lMiccGbo=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=https://example.com/docs/Java/index.xml title="Hugo Book"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Hugo Book</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><a href=/docs/example/>Example Site</a><ul><li><a href=/docs/example/table-of-contents/>Table of Contents</a><ul><li><a href=/docs/example/table-of-contents/with-toc/>With ToC</a></li><li><a href=/docs/example/table-of-contents/without-toc/>Without ToC</a></li></ul></li><li><input type=checkbox id=section-4e46b01272d410b3a99461d79326ddf4 class=toggle>
<label for=section-4e46b01272d410b3a99461d79326ddf4 class="flex justify-between"><a role=button>Collapsed</a></label><ul><li><a href=/docs/example/collapsed/3rd-level/>3rd Level</a><ul><li><a href=/docs/example/collapsed/3rd-level/4th-level/>4th Level</a></li></ul></li></ul></li></ul></li><li><a href=/docs/Java/ class=active>Java</a><ul><li><a href=/docs/Java/BaseEntity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>Base Entity源码分析</a></li><li><a href=/docs/Java/java/>Java</a></li><li><a href=/docs/Java/JVM%E7%AC%94%E8%AE%B0/>Jvm笔记</a></li></ul></li><li><a href=/docs/LeetCode/>Leet Code</a><ul><li><a href=/docs/LeetCode/%E4%BA%8C%E5%8F%89%E6%A0%91/>二叉树</a></li><li><a href=/docs/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/>动态规划</a></li></ul></li><li class=book-section-flat><span>Shortcodes</span><ul><li><a href=/docs/shortcodes/buttons/>Buttons</a></li><li><a href=/docs/shortcodes/columns/>Columns</a></li><li><a href=/docs/shortcodes/details/>Details</a></li><li><a href=/docs/shortcodes/expand/>Expand</a></li><li><a href=/docs/shortcodes/hints/>Hints</a></li><li><a href=/docs/shortcodes/katex/>Katex</a></li><li><a href=/docs/shortcodes/mermaid/>Mermaid</a></li><li><input type=checkbox id=section-d3fc1bf6d66cd84b896a0af9f40cb1d5 class=toggle>
<label for=section-d3fc1bf6d66cd84b896a0af9f40cb1d5 class="flex justify-between"><a href=/docs/shortcodes/section/>Section</a></label><ul><li><a href=/docs/shortcodes/section/first-page/>First Page</a></li><li><a href=/docs/shortcodes/section/second-page/>Second Page</a></li></ul></li><li><a href=/docs/shortcodes/tabs/>Tabs</a></li></ul></li></ul><ul><li><a href=/posts/>Blog</a></li><li><a href=https://github.com/alex-shpak/hugo-book target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Java</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#目录>目录</a></li></ul></nav></aside></header><article class=markdown><h1 id=目录>目录
<a class=anchor href=#%e7%9b%ae%e5%bd%95>#</a></h1><dl><dt><a href=/docs/Java/BaseEntity%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>Base Entity源码分析</a></dt><dd class=markdown-inner>开发中发现许多对象都依赖了css的基类对象BaseEntity 偶然点开发现里面的写法不太容易理解，因此分析记录一下
点开对象可以发现，有两个属性是比较特别的，也就是 propMap 和 visitor 本文的目的也主要是分析这两个对象的用途。
![[/static/img/Pasted image 20230505092032.png]]
先直接看这两个对象在哪用了，翻阅源码可以发现，两个属性的主要使用入口都在toString中。 最终这个函数是调用了toString0 或者 hexString 初见这一坨，我也百思不得其解，先不管，继续看看toString0 ![[/static/img/Pasted image 20230505103131.png]]
分析代码可知，toString0这个方法才是对象转字符串的主要实现，通过getProps获取对象的属性列表，然后在下面进行属性的拼接 ![[/static/img/Pasted image 20230505103619.png]]
看看getProps，可以发现propMap的用途是存储该类的所有属性名称。 如果该对象的属性未初始化，则通过反射获取。 ![[/static/img/Pasted image 20230512180112.png]] 需要注意的是，这里使用了 double check lock，避免重入。 当第二次进入时，就可以复用属性，不用再反射获取了。 到了此处，propMap 的用途基本就解答了。
那么为啥要有 visotor 呢？我们再回过头来看toString方法 ![[/static/img/Pasted image 20230512173325.png]]
在toString方法中，visitor 的逻辑主要如下
如果 visitor为空，重新初始化 visitor 如果 visitor.get() 为空： 1. 设置 visitor 为当前对象 2. 调用 toString0 3. 设置 visitor 为 null 如果 visitor 的值不为空，返回 HexString 这里的目的不太好理解。首先对于步骤1，我们可以先忽略，因为实际不影响流程。 控制流程的主要是步骤2和步骤3。 首先可以观察到，步骤2的进入条件是 visitor 为空，步骤3的进入条件为 visitor 不为空。也就是说，步骤2和步骤3这两步操作是互斥的。 在步骤2.</dd><dt><a href=/docs/Java/java/>Java</a></dt><dd class=markdown-inner>First page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</dd><dt><a href=/docs/Java/JVM%E7%AC%94%E8%AE%B0/>Jvm笔记</a></dt><dd class=markdown-inner>为什么有JVM # 在学习JVM之前，大家可以先思考一个问题，为什么我们需要JVM
以上图为例，cpp开发的软件具备一个明显劣势，那就是他无法满足跨平台的需求(一次编写，处处编译)
计算机领域有一句名言：
计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.
JVM便是通过增加中间层实现了 一次编译，处处运行
JVM能做什么 # 平台无关性 语言无关性 JVM运行机制 # 垃圾回收算法 # 除了上面的跨平台性，Java 和 cpp相比，还有一个显著的区别，那就是内存动态分配和垃圾回收。
对于GC，我们需要考虑2个问题：
哪些内存需要回收? 如何回收? 程序计数器、虚拟机栈、本地方法栈 3 个区域是 Thread Local 的，随线程而生，随线程而灭，自然也不用过多关心如何回收的问题。
然而 Heap 和方法区有显著的不确定性，这部分内存更是实际中用得最多的内存，也因此诞生了许多分配与回收算法。
引用计数 # 引用记数（Reference Counting）是最简单的一种收集方法，许多编程语言使用该方法管理内存（Objective-C、Swift 等）
它的缺点和优势都很明显。它的判定效率高，占用低。然而仍然需要程序员在编码时额外配合，必须手动将对象置空。
除此之外，它无法解决循环引用问题。
可达性分析 # 当一块内存永远不可能再被访问到时，他就应该回收
如图所示，该算法的主要思路是把一系列被称作「GC Roots」的根对象作为起始节点，从这些节点开始往下搜索，搜索过的路径称作「引用链」（Reference Chain）。如果某个对象和 GC Roots 间没有引用链连接。就说明该对象不可达，也就不可能再被使用。
在 JVM 中，可作为 GC Roots 的对象有以下几种：
VM Stack 中引用的对象，如方法参数、局部变量、临时变量等。 在方法区内的静态属性对象 在方法去内常量引用的对象，如字符串常量池（String Table）中的引用 本地方法栈中 JNI 引用的对象 JVM 内部引用，如基本数据类型对应的 Class 对象，一些长驻的异常对象（NPE OOM 等），以及类加载器。 所有被同步锁（synchronized 关键字）持有的对象 JMXBean、JVMTI 中的回调、本地代码缓存等 垃圾回收算法 # 分代收集（Generational Collection）理论是最广泛应用的垃圾收集理论，建立在两个分代假说之上：</dd></dl></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/commit/7cdc0d553b9cdb59e7261f59d7fafb7e3de4019e title='Last modified by unknown | May 16, 2023' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>May 16, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/docs/Java/_index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#目录>目录</a></li></ul></nav></div></aside></main></body></html>