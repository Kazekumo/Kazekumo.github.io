---
title: "JVM简介"
date: "2023-05-15"
description: "jvm主体架构及垃圾回收算法的介绍"
tags: ["jvm"]
ShowToc: false
ShowBreadCrumbs: true
math: true
---

## 为什么有JVM

在学习JVM(Java Virtual Machine)之前，大家可以先思考一个问题，为什么我们需要JVM

![7-zip](images/1684068915223-5287d1b8-12d6-4e71-baf9-91d6460af5ac.png)

以上图为例，cpp开发的软件具备一个明显劣势，那就是他无法满足跨平台的需求(一次编写，处处编译)

![software-architecture](images/1684069790603-1ec2b3d8-cb44-4201-bdc2-bd2e52f60ef2.png)

计算机领域有一句名言：

> 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.

JVM便是通过增加中间层实现了"一次编译，处处运行"

![jvm-run-everywhere](images/1684069989306-e10efadc-c278-4534-8c54-4ec17fe7ee60.png)

## JVM能做什么

- 平台无关性: 通过class文件将程序和机器环境进行解耦，运行时再翻译成机器码
- 语言无关性: JVM不与Java等任何程序语言进行绑定，只要是符合标准的class文件都可以运行在JVM上

![cross-platform](images/1684071639796-32385ee0-03e7-4863-8d4e-a50045548397.png)

## JVM运行机制

![jvm-architecture](images/1684070465917-8dd6bf36-f48e-464e-bbbf-e110919c0603.png)

## 垃圾回收算法

除了上面的跨平台性，Java 和 cpp相比，还有一个显著的区别，那就是内存动态分配和垃圾回收。

对于GC(Garbage Collection)，我们需要考虑2个问题：

- 哪些内存需要回收?
- 如何回收?

程序计数器、虚拟机栈、本地方法栈 3 个区域是 Thread Local 的，随线程而生，随线程而灭，不用过多关心如何回收的问题。

然而 Heap 和方法区有显著的不确定性，这部分内存更是实际中用得最多的内存，也因此诞生了许多分配与回收算法。

### 引用计数

**引用记数**（Reference Counting）是最简单的一种收集方法，许多编程语言使用该方法管理内存（Objective-C、Swift 等）

它的缺点和优势都很明显。它的判定效率高，占用低。然而需要程序员在编码时额外配合，必须手动将对象置空。

除此之外，它无法解决循环引用问题。

![ref-count](images/1684076436956-92176dc5-2397-47a4-be50-94c379bb3131.webp)

### 可达性分析

当一块内存永远不可能再被访问到时，他就应该被回收。

![](images/1684076188174-78f0079e-9ce0-47dd-9eb2-12ddef627a09.webp)

如图所示，该算法的主要思路是把一系列被称作「GC Roots」的根对象作为起始节点，从这些节点开始往下搜索，搜索过的路径称作「引用链」（Reference Chain）。如果某个对象和 GC Roots 间没有引用链连接。就说明该对象不可达，也就不可能再被使用。

在 JVM 中，可作为 GC Roots 的对象有以下几种：

- VM Stack 中引用的对象，如方法参数、局部变量、临时变量等。
- 在方法区内的静态属性对象
- 在方法去内常量引用的对象，如字符串常量池（String Table）中的引用
- 本地方法栈中 JNI 引用的对象
- JVM 内部引用，如基本数据类型对应的 Class 对象，一些长驻的异常对象（NPE OOM 等），以及类加载器。
- 所有被同步锁（synchronized 关键字）持有的对象
- JMXBean、JVMTI 中的回调、本地代码缓存等

### 分代假说

研究人员发现，Java对象的生命周期符合如下3个假说：

- 弱分代假说（Weak Generational Hypothesis）：绝大多数对象是朝生夕灭的
- 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡
- 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说是极少的

以上几个分代假说，奠定了多款常用的垃圾收集器的设计原则：

- 收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。
- 在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，同时能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。
- 跨代引用是极少的，因此没必要在新生代垃圾回收时扫描整个老年代，只需建立一个全局的数据结构 记忆集（Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。

### 清除算法

#### 标记-清除

最基础的 GC 算法是「**标记-清除**」（Mark-Sweep）。分为「标记」、「清除」两个阶段。首先标记出所有需要回收的对象，然后统一回收。

如图：

![](images/1684076602032-1f2caced-02d9-457c-be30-023a422f1b10.webp)

缺点：内存空间碎片化，如果无法给一个大对象分配足够空间，JVM 会提前触发 Full GC。

#### 标记-复制

**标记-复制**（mark-copying）算法将内存分为两块。若一块内存用毕，就对这块区域进行一次垃圾收集，将还存活的对象复制到另一块区域上。每次只使用一块，并将另一块内存保留。

![](images/1684076954041-0dc4d60d-237d-4a3a-9a6e-7da07382fc74.webp)

相较于标记-清除算法，标记-复制的算法的优点是不会产生碎片。

但他的缺点也很明显：有额外的复制开销，并且内存利用率最多只有50%。

回想一下分代假设：1. 大多数对象朝生夕灭；2. 熬过越多次 GC 的对象，越难以消亡。

对于新生代中的对象，由于其朝生夕灭的特性，就非常适合 Mark-Copy 算法。

现代JVM中，还对Mark-Copy进行了优化，将新生代分为较大的一块 Eden 和两块 Survivor。分配时使用 Eden 和一块 Survivor。GC 时，将 Eden 和其中一块 Survivor 内存区域中的存活对象，复制到另一块 Survivor 空间上。HotSpot VM 默认的比例为 Eden:Survivor=8:1 。也就是说，只有 10%的内存会被浪费（因为有两块 Survivor，最终比例是 8:1:1）。

#### 标记-整理

对于老年代，对象存活率较高，较多的复制操作会导致性能下降，此时就不适用标记-复制算法了。

针对老年代特征，可以使用**标记-整理**（Mark-Compact）算法。其标记过程和"标记-清除"算法一样，但后续不是清理可回收对象，而是直接让所有存活对象都向一端移动，直接清理掉端边界外的内存。

![](images/1684076667160-024c7348-db86-47f5-ae7a-c7e3ccdf259d.webp)

然而，移动存活对象的代价是很高的，尤其是老年代这种大区块。移动存活对象并更新引用是一项沉重、耗时的操作，必须停止整个程序 stop the world。 极大影响程序的**响应速度**。

## 垃圾收集器

分代收集算法概念：根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为新生代、老年代和永久代，并根据各个年代的特点分别采用不同的GC算法。

这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。根据系统可接受的停顿时间，每次都快速回收若干个小区域，从而减少一次GC所产生的的停顿时间，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。

|  分代   | 适用算法  | 特点|
|  ----  | ----  |----  |
| 新生代  | 标记-复制算法 |对象生命周期短，标记阶段会标记大量已死亡对象
| 老年代  | 标记-整理算法 |生命周期长的对象、大对象，可回收数量少 |
| 永久代  | 回收废弃的常量、无用的类 |存储Class类、常量、方法描述等 |

除了分代收集算法外，还有分区收集算法，其特点是直接将堆内存分为多个大小相等的独立空间(Region)。

![](images/1684160904333-0fde3ca6-d2a2-4c44-9361-631f79be278f.png)

衡量垃圾收集器的三个重要指标是：内存占用(Footprint)、吞吐量(Throught)和延迟(Latency)，三者共同构成了一个"不可能三角"，要同时在这三个方面具有卓越表现几乎是不可能的。因此垃圾回收器在设计时也会有所偏向。

### Serial收集器（新生代）

- 客户端模式下的默认新生代收集器；
- 简单而高效，额外的内存消耗最小；
- 可以管理较小内存（几十兆到一两百兆内存）

![](images/1657553548237-5ba2fb2c-4bb6-4183-ab53-697372f3bf75.png)

### Serial Old收集器（老年代）

单线程的老年代垃圾回收器。

![](images/1657553682670-d4ab211f-97eb-4ce6-97e2-bc0aa1631632.png)

### ParNew收集器（新生代）

多线程并行版的Serial新生代垃圾回收器。除了 Serial 收集器外，目前只有 ParNew 能与 CMS 收集器配合工作。

![](images/1657553579114-0754ec31-b112-4cc1-86ea-5781bc11ecd8.png)

### Parallel Scavenge收集器（新生代）

- 新生代收集器；
- 基于标记–复制算法的收集器；
- 并行收集的多线程收集器；
- 可控制吞吐量的收集器。

这款垃圾回收器又被称为吞吐量优先收集器。适用于跑批应用，不用太在乎单次STW卡顿时间，只要能够尽可能得利用CPU资源跑完程序就好。

$$ 吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间} $$

这款收集器有以下几个关键参数：

- -XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间；该参数允许的值是一个大于 0 的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值；

- -XX:GCTimeRatio：直接设置吞吐量大小，该参数的值是一个大于 0 小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为 19，那允许的最大垃圾收集时间就占总时间的 5%（即1/(1+19)），默认值为 99，即允许最大 1%（即1/(1+99)）的垃圾收集时间。

- -XX:+UseAdaptiveSizePolicy：开启自适应调节策略，当这个参数被激活之后，就不需要设置分区占比等参数细节了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

### Parallel Old收集器（老年代）

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。

![](images/1657553744602-35378cd9-f192-48bb-99ac-7f71d4420a33.png)

### CMS收集器（老年代）

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它在垃圾回收期间和用户程序并发可以做到一定程度的并发，适合用在面向互联网用户的服务器应用。
该收集器基于标记–清除算法实现。

CMS 垃圾收集四个步骤：

- 初始标记（CMS initial mark）：Stop The World，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；

- 并发标记（CMS concurrent mark）：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；

- 重新标记（CMS remark）：Stop The World，重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；

- 并发清除（CMS concurrent sweep）：并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

![](images/1657813406293-1cd958b5-a4b0-4f52-b913-40b75fe35696.png)

CMS 垃圾收集器不足：

**1）对处理器资源敏感**

CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。

**2）CMS 垃圾收集器无法处理“浮动垃圾（Floating Garbage）**

在CMS的并发标记和并发清理阶段，用户线程还在继续运行，用户线程会产生新的对象。由于这部分垃圾出现在标记过程结束之后，CMS无法在当次收集中处理掉它们，只好等待下一次垃圾回收再清理。并且由于CMS收集器会和用户线程并发，不能等老年代满了再进行收集，必须预留一部分空间给用户线程。因此有一个参数（-XX：CMSInitiatingOccu-pancyFraction）控制老年代占用内存比例到达多少时触发垃圾回收，默认值是92%。如果并发期间分配对象还是失败，就会触发一次兜底的Serial Old收集。

**3）基于标记–清除算法实现，会产生内存碎片。**

CMS是一款基于"标记-清除"算法实现的垃圾回收器，因此会产生大量的内存碎片，这将导致大对象的分配带来麻烦。因此CMS提供了如下参数进行碎片整理。
-XX:+UseCMS-CompactAtFullCollection：在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，该参数是默认开启的；
-XX:CMSFullGCsBefore-Compaction：这个参数的作用是要求 CMS 收集器在执行过若干次（数量由参数值决定）不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。

### G1收集器（混合代）

之前的所讲述的收集器，垃圾回收的目标范围是整个新生代，要么是整个老年代，再要么是整个Java堆。而G1(Garbage First)收集器跳出了这个樊笼，它可以面向堆内存的任何部分进行回收，衡量标准不再是分代，而是哪块内存中存放的垃圾数量最多。

![](images/1657849044831-805135b8-6c89-42b9-a6b0-3cee345aeae4.png)

G1把连续的堆内存划分为多个大小相等的独立区域(Region)，Region 的类型有 Eden、Survivor、Old、Humongous 四种。收集器对扮演不同角色的Region采用不同的策略去处理。

G1收集器的核心思路是建立可靠的停顿预测模型(通过- XX：MaxGCPauseMillis，控制收集停顿时间，默认200ms)，跟踪各个Region中垃圾堆积的"价值"，优先处理回收价值收益最大的Region。其不追求一次清理所有垃圾，而是只要能够应付应用的内存分配速率(Allocation Rate)即可。

## 启示和展望

限于篇幅，虽然本文叫做简介，却只讲了JVM主体架构和垃圾收集器，省略了许多有趣的内容，如类加载机制、类增强机制、编译时优化，运行时优化，内存分配机制等等。在阅读《深入理解Java虚拟机》的过程中，这些内容都一一得到阐释，也不由的感慨JVM设计的如此之好，以至于程序员们几乎感受不到他的存在。

其实在使用Java的过程中，一直有一个疑问：在云原生浪潮席卷的今天，软件环境已然发生了天翻地覆的变化，和十数年前相比，服务端场景并不需要跨平台性，此时JVM究竟给我们带来的是性能的损耗，还是内存管理的便利性？

在这种背景下, [GraalVM](https://www.graalvm.org/) 应运而生，这是一个在 HotSpot 虚拟机基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。

或许有一天我们仍在写Java，却再也看不到JVM的踪影了。

## ref

深入理解Java虚拟机 [https://book.douban.com/subject/34907497/](https://book.douban.com/subject/34907497/)

jvm参数生成及工具指引 [https://render.alipay.com/p/s/jvm-generate/JvmGenerate](https://render.alipay.com/p/s/jvm-generate/JvmGenerate)

jvm在线诊断 [https://arthas.aliyun.com/](https://arthas.aliyun.com/)

gc日志在线分析 [https://gceasy.io/](https://gceasy.io/)

[如何用好Java虚拟机](https://www.yuque.com/belber/archive/bhgel2?##QWTJx)
