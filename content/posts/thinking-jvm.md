---
title: "JVM笔记"
date: "2023-05-15"
description: "jvm主体架构及垃圾回收算法的介绍"
tags: ["jvm"]
ShowToc: false
ShowBreadCrumbs: true
---

# 为什么有JVM

在学习JVM之前，大家可以先思考一个问题，为什么我们需要JVM

![](/1684068915223-5287d1b8-12d6-4e71-baf9-91d6460af5ac.png)

  

以上图为例，cpp开发的软件具备一个明显劣势，那就是他无法满足跨平台的需求(一次编写，处处编译)

![](/1684069790603-1ec2b3d8-cb44-4201-bdc2-bd2e52f60ef2.png)

  

  

计算机领域有一句名言：

计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.

JVM便是通过增加中间层实现了 一次编译，处处运行

![](/1684069989306-e10efadc-c278-4534-8c54-4ec17fe7ee60.png)

# JVM能做什么

-   平台无关性
-   语言无关性

![](/1684071639796-32385ee0-03e7-4863-8d4e-a50045548397.png)

# JVM运行机制
![](/1684070465917-8dd6bf36-f48e-464e-bbbf-e110919c0603.png)

# 垃圾回收算法

除了上面的跨平台性，Java 和 cpp相比，还有一个显著的区别，那就是内存动态分配和垃圾回收。

对于GC，我们需要考虑2个问题：

-   哪些内存需要回收?
-   如何回收?

程序计数器、虚拟机栈、本地方法栈 3 个区域是 Thread Local 的，随线程而生，随线程而灭，自然也不用过多关心如何回收的问题。

然而 Heap 和方法区有显著的不确定性，这部分内存更是实际中用得最多的内存，也因此诞生了许多分配与回收算法。

## 引用计数

**引用记数**（Reference Counting）是最简单的一种收集方法，许多编程语言使用该方法管理内存（Objective-C、Swift 等）

它的缺点和优势都很明显。它的判定效率高，占用低。然而仍然需要程序员在编码时额外配合，必须手动将对象置空。

除此之外，它无法解决循环引用问题。

![](/1684076436956-92176dc5-2397-47a4-be50-94c379bb3131.webp)

## 可达性分析

当一块内存永远不可能再被访问到时，他就应该回收

![](/1684076188174-78f0079e-9ce0-47dd-9eb2-12ddef627a09.webp)

如图所示，该算法的主要思路是把一系列被称作「GC Roots」的根对象作为起始节点，从这些节点开始往下搜索，搜索过的路径称作「引用链」（Reference Chain）。如果某个对象和 GC Roots 间没有引用链连接。就说明该对象不可达，也就不可能再被使用。

在 JVM 中，可作为 GC Roots 的对象有以下几种：

-   VM Stack 中引用的对象，如方法参数、局部变量、临时变量等。
-   在方法区内的静态属性对象
-   在方法去内常量引用的对象，如字符串常量池（String Table）中的引用
-   本地方法栈中 JNI 引用的对象
-   JVM 内部引用，如基本数据类型对应的 Class 对象，一些长驻的异常对象（NPE OOM 等），以及类加载器。
-   所有被同步锁（synchronized 关键字）持有的对象
-   JMXBean、JVMTI 中的回调、本地代码缓存等

## 垃圾回收算法

分代收集（Generational Collection）理论是最广泛应用的垃圾收集理论，建立在两个分代假说之上：

-   弱分代假说（Weak Generational Hypothesis）：大多数对象朝生夕灭
-   强分代假说（Strong Generational Hypothesis）：熬过越多次 GC 的对象，越难以消亡

因此，很容易想到将内存划分为多个区域，针对不同区域的特点，优化收集算法。很多 JVM GC 就是这么做的。

譬如，可以将 Heap 分为新生代和老年代。很多对象在新生代中就会死去，而熬过 GC 的对象，就可以逐步放到老年代中管理。所以，JVM 可以每次只回收其中某一个或者某些部分的区域。从而还出现了「Minor GC」「Major GC」「Full GC」这样的划分。

然而这样的模型仍然是不完备的。比如，现在要进行一次 Minor GC（只清除新生代），但新生代中的对象却可能被老年代所引用。为了找出新生代的存活对象，却不得不在 GC Roots 之外，额外搜讯老年代中所有对象，来确保可达性分析的正确性，反之亦然。为了避免造成极大的性能损失，还需要第三条假说：

-   跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用对比同代引用，少之又少

基于 1、2 两条假说，推出这条很自然：两个存在引用关系的对象，倾向于同生同死。比如，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，所以新生代也会逐渐晋升到老年代中，跨代引用也就被消除了。

因此 Minor GC 时，就不必扫描整个老年代，而是只扫描相关的区域。这样就可以极大减少运行时开销。

后续会使用的 GC Term：

-   Partial GC：不完整收集整个 Heap 的 GC

-   Minor GC / Young GC：只收集新生代
-   Major GC / Old GC：本文中指只收集老年代，然而这个说法常常和 Full GC 混淆，需要根据上下文判断。

-   Mixed GC：混合收集新生代和老年代。
-   Full GC：收集整个 Heap 和方法区。

## 清除算法

### 标记-清除

最基础的 GC 算法是「**标记-清除**」（Mark-Sweep）。分为「标记」、「清除」两个阶段。首先标记出所有需要回收的对象，然后统一回收。标记过程之前已经讲过了。

如图：

![](/1684076602032-1f2caced-02d9-457c-be30-023a422f1b10.webp)

他的缺点很明显：

1.  效率低，JVM 需要大量的标记和清除操作，随着对象数量增长，速度会极速下降
2.  内存空间碎片化，会产生大量不连续的内存空间，导致内存利用率不高

### 标记-复制

**标记-复制**（mark-copying）算法将内存分为两块。若一块内存用毕，就对这块区域进行一次垃圾收集，将还存活的对象复制到另一块区域上。每次只使用一块，并将另一块内存保留。

![](/1684076954041-0dc4d60d-237d-4a3a-9a6e-7da07382fc74.webp)

若回收时多数对象都是存活的，这将会产生大量复制开销。但如果多数对象都是死亡的，那么复制开销就很低。同时，也毋须考虑碎片化问题，因为会直接清除一个区块的内存。当然，缺点也显而易见，**这浪费了一半的内存**。

回想一下分代假设：1. 大多数对象朝生夕灭；2. 熬过越多次 GC 的对象，越难以消亡。

因此对于新生代中的对象，就非常适合 Mark-Copy 算法。

在 1989 年，Andrew Appel 就提出了将 Mark-Copy 优化后的策略。将新生代分为较大的一块 Eden 和两块 Survivor。分配时使用 Eden 和一块 Survivor。GC 时，将 Eden 和其中一块 Survivor 内存区域中的存活对象，复制到另一块 Survivor 空间上。HotSpot VM 默认的比例为 Eden:Survivor=8:1Eden:Survivor=8:1 。也就是说，只有 10%10% 的内存会被浪费（因为有两块 Survivor，最终比例是 8:1:18:1:1）。

此外，还需要考虑到大量创建对象的极端情况。因此就有**分配担保**（Handle Promotion）机制。可以直接将新对象放入老年代，避免反复收集。具体细节，会在以后详解。

### 标记-整理

标记-复制算法固然能在新生代大放光彩，然而若在老年代，对象存活率较高，较多的复制操作会让性能骤降。

针对老年代特征，可以使用**标记-整理**（Mark-Compact）算法。其机制就是在标记-清楚基础之上，增加一个移动内存的步骤。

![](/1684076667160-024c7348-db86-47f5-ae7a-c7e3ccdf259d.webp)

然而，移动存活对象的代价是很高的，尤其是老年代这种大区块。移动存活对象并更新引用是一项沉重、耗时的操作，必须停止整个程序进行 GC，i.e. stop the world. 极大影响程序的**响应速度**。

如果你玩过 Minecraft Java 版，那么你很有可能已经经历过其中的酸爽了。程序占用的内存到达了 JVM 设置的上限。反复地经历新对象创建和 Full GC 循环，反复停止整个程序[^1]。（这种情况也被某些人叫做「内存抖动」）体现在游戏中，就是每隔几秒画面静止一下，体验非常差。

当然，这里是指多数 GC 会停止整个程序。较新的一些 GC，如 ZGC，可以通过其他手段避免暂停全局。

然而，若不 Compact，空间碎片化问题同样恼人。可以使用分区等方式将物理上不连续的内存，化为逻辑上连续的。（硬盘正是这么做的）但这会降低程序的**吞吐量**。

# 垃圾收集器

分代收集算法概念：根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为新生代、老年代和永久代，并根据各个年代的特点分别采用不同的GC算法

新生代——负责算法

老年代——标记整理算法

  

特点

适用算法

新生代

对象生命周期短，标记阶段会标记大量已死亡对象

复制算法

老年代

生命周期长的对象、大对象，可回收数量少

标记整理算法

永久代

存储Class类、常量、方法描述等

回收废弃的常量、无用的类

分区收集算法概念：将整个堆空间划分为连续的大小不同的小区域，每个小区域单独进行内存使用和垃圾回收，这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。根据系统可接受的停顿时间，每次都快速回收若干个小区域，从而减少一次GC所产生的的停顿时间，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。

![](/1684160904333-0fde3ca6-d2a2-4c44-9361-631f79be278f.png)

### Serial收集器（年轻代）

最简单高效粗暴的单线程年轻代垃圾回收器，但是STW/延迟时间最长。

但是并不是一无是处，适合用在一些小内存的客户端程序，比如几百M的内存只要100毫秒以内就可以回收完，对用户没什么影响。

![](/1657553548237-5ba2fb2c-4bb6-4183-ab53-697372f3bf75.png)

### ParNew收集器（年轻代）

多线程并行版的Serial年轻代垃圾回收器。

![](/1657553579114-0754ec31-b112-4cc1-86ea-5781bc11ecd8.png)

### Serial Old收集器（老年代）

单线程的老年代垃圾回收器。

![](/1657553682670-d4ab211f-97eb-4ce6-97e2-bc0aa1631632.png)

### Parallel Old收集器（老年代）

多线程的并行老年代回收器。

![](/1657553744602-35378cd9-f192-48bb-99ac-7f71d4420a33.png)

### Parallel Scanvenge收集器（年轻代）

也是多线程并发的年轻代回收器，但是这款垃圾回收器不是考虑如何缩短STW，而是吞吐量，即如何减少垃圾回收器总的回收时间，保障用户执行时间。所以可以应用的场景是跑批的应用，不用太在乎单次STW卡顿时间，只要能够尽可能得利用CPU资源跑完程序就好。

用这个垃圾回收器有3个关键参数要注意：

-   **吞吐量**（-XX：GCTimeRatio）：设置为99%，意味着100分钟里，只有1分钟在垃圾回收，99分钟都在跑用户代码。
-   **单次最大垃圾回收时间**（-XX：MaxGCPauseMillis）：效果与吞吐量相反的参数是。这两个参数是相互矛盾的，所以二选一，要么吞吐量优先，要么限制单次垃圾回收时间优先。

问题：那么是不是可以把单次最大垃圾回收时间设置得非常短，那岂不是就不会有卡顿？

答：垃圾收集停顿时间缩短是**以牺牲吞吐量和新生代空间为代价换取**的：系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。

-   **内存自适应**（-XX：+UseAdaptiveSizePolicy）：只要设置最大堆大小（-Xmx）就可以，不用关注年轻代大小、Eden和Survivor比例等。

所以这个垃圾回收器的一般用法是：设置最大堆大小（-Xmx），内存选择自适应（-XX：+UseAdaptiveSizePolicy），不用管年轻代大小、Eden和Survivor比例，然后告诉虚拟机吞吐量目标（-XX：GCTimeRatio）或者少延迟/卡顿优先（-XX：MaxGCPauseMillis）。

### CMS（ConcurrentMarkSweep）收集器（老年代）

比并发的老年代收集器Parallel Old又在进步一些，追求垃圾回收期间与用户程序并发、且低延迟，适合用在面向互联网用户的服务器应用。垃圾收集算法是标记-清除，清除不会造成STW，所以优化点是标记，用到前面讲到的办法将标记过程拆细，分为初始标记（卡顿）、并发标记（无需卡顿）、二次标记（卡顿），初始标记、二次标记虽然卡顿但时间都很短。步骤分为四步：

1）初始标记（CMSinitialmark）：会卡顿

2）并发标记（CMSconcurrentmark）：

3）二次/重新标记（CMSremark）：会卡顿

4）并发清除（CMSconcurrentsweep）

![](/1657813406293-1cd958b5-a4b0-4f52-b913-40b75fe35696.png)

有3个关键问题：

**1）虽然可以并发进行标记、清理减少卡顿，但是多线程并行会消耗机器资源导致用户程序变慢，吞吐量降低。**

使用这款垃圾回收器要注意CPU核数的选择：CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。**但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。**如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。

**2）并发标记、并发清理过程中用户程序又分配新对象怎么办？**

跟其他垃圾回收器不一样，不能等到老年代满了才进行垃圾回收了，因为回收过程中与用户线程并发，用户线程会产生新的对象，因此有一个参数（-XX：CMSInitiatingOccu-pancyFraction）控制老年代占用内存比例到达多少时触发垃圾回收，默认值是92%。如果并发期间分配对象还是失败，就会触发一次兜底的Serial Old。

**3）标记-清除算法内存碎片问题**

如果多次标记-清除，内存碎片太多无法找到足够大的连续空间分配对象，就会触发一次带内存碎片整理的Full GC（- XX：+ UseCMS-CompactAtFullCollection参数控制Full GC前是否需要内存整理，默认开启。

一个收集器就可以搞定整个内存的垃圾回收，不需要配置两个年轻代和老年代的垃圾回收器了，因为内存布局跟原来完全不一样了，年轻代和老年代粒度变小了，如下图，这种方式叫基于Region的内存布局，每个Region大小相等。

![](/1657849044831-805135b8-6c89-42b9-a6b0-3cee345aeae4.png)

这么设计有什么好处？

和垃圾回收器G1（Garbage First）的命名相关，追求的目标是固定一个延迟时间，不再区分回收年轻代还是老年代，而是回收价值最大（能够回收最多内存的的区域），Garbage First可以叫回收效益排名第一的垃圾回收器。

关键参数- XX：MaxGCPauseMillis，默认值是200ms，核心的实现思路是建议停顿预测模型，即记录回收每个Region可能需要耗费的时间。

每次回收的过程跟CMS差不多，不过用的是标记-复制。

1）初始标记(Initial Marking)：会卡顿

2）并发标记（Concurrent Marking）

3）最终标记（Final Marking）：会卡顿

4）筛选回收（Live Data Counting and Evacuation)：回收价值最高的Region，用复制算法，会卡顿

# 启示和展望

架构的本质是领域划分和依赖分析

依赖的原则：1.显示依赖 2.每层只能与位于其下方的层发生耦合

JVM设计之时的市场环境和现在已经发生了天翻地覆的变化，不由让我们思考这样一个问题：我们是否还需要JVM? 我们是否真的还需要平台无关性？

将在的Java JVM 和 浏览器的v8引擎 进行比较，可以很明显的发现，我们不再需要客户端了，也不再需要平台无关性了，服务端的一切我们都是可控的。面对云原生的浪潮，Java将做出什么样的改变，这个问题就留给读者思考了。

# ref

深入理解Java虚拟机 [https://book.douban.com/subject/34907497/](https://book.douban.com/subject/34907497/)

jvm参数生成及工具指引 [https://render.alipay.com/p/s/jvm-generate/JvmGenerate](https://render.alipay.com/p/s/jvm-generate/JvmGenerate)

jvm在线诊断 [https://arthas.aliyun.com/](https://arthas.aliyun.com/)

gc日志在线分析 [https://gceasy.io/](https://gceasy.io/)

[https://www.yuque.com/belber/archive/bhgel2?#QWTJx](https://www.yuque.com/belber/archive/bhgel2?#QWTJx)