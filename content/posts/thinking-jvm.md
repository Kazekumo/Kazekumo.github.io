---
title: "JVM笔记"
date: "2023-05-15"
description: "jvm主体架构及垃圾回收算法的介绍"
tags: ["jvm"]
ShowToc: false
ShowBreadCrumbs: true
---

# 为什么有JVM

在学习JVM(Java Virtual Machine )之前，大家可以先思考一个问题，为什么我们需要JVM

![](/1684068915223-5287d1b8-12d6-4e71-baf9-91d6460af5ac.png)

  

以上图为例，cpp开发的软件具备一个明显劣势，那就是他无法满足跨平台的需求(一次编写，处处编译)

![](/1684069790603-1ec2b3d8-cb44-4201-bdc2-bd2e52f60ef2.png)

  

  

计算机领域有一句名言：

> 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.

JVM便是通过增加中间层实现了`一次编译，处处运行`

![](/1684069989306-e10efadc-c278-4534-8c54-4ec17fe7ee60.png)

# JVM能做什么

-   平台无关性: 通过class文件将程序和机器环境进行解耦，运行时再翻译成机器码
-   语言无关性: JVM不与Java等任何程序语言进行绑定，只要是符合标准的class文件都可以运行在JVM上

![](/1684071639796-32385ee0-03e7-4863-8d4e-a50045548397.png)

# JVM运行机制
![](/1684070465917-8dd6bf36-f48e-464e-bbbf-e110919c0603.png)

# 垃圾回收

除了上面的跨平台性，Java 和 cpp相比，还有一个显著的区别，那就是内存动态分配和垃圾回收。

对于GC(Garbage Collection)，我们需要考虑2个问题：

-   哪些内存需要回收?
-   如何回收?

程序计数器、虚拟机栈、本地方法栈 3 个区域是 Thread Local 的，随线程而生，随线程而灭，自然也不用过多关心如何回收的问题。

然而 Heap 和方法区有显著的不确定性，这部分内存更是实际中用得最多的内存，也因此诞生了许多分配与回收算法。

## 引用计数

**引用记数**（Reference Counting）是最简单的一种收集方法，许多编程语言使用该方法管理内存（Objective-C、Swift 等）

它的缺点和优势都很明显。它的判定效率高，占用低。然而仍然需要程序员在编码时额外配合，必须手动将对象置空。

除此之外，它无法解决循环引用问题。

![](/1684076436956-92176dc5-2397-47a4-be50-94c379bb3131.webp)

## 可达性分析

当一块内存永远不可能再被访问到时，他就应该被回收。

![](/1684076188174-78f0079e-9ce0-47dd-9eb2-12ddef627a09.webp)

如图所示，该算法的主要思路是把一系列被称作「GC Roots」的根对象作为起始节点，从这些节点开始往下搜索，搜索过的路径称作「引用链」（Reference Chain）。如果某个对象和 GC Roots 间没有引用链连接。就说明该对象不可达，也就不可能再被使用。

在 JVM 中，可作为 GC Roots 的对象有以下几种：

-   VM Stack 中引用的对象，如方法参数、局部变量、临时变量等。
-   在方法区内的静态属性对象
-   在方法去内常量引用的对象，如字符串常量池（String Table）中的引用
-   本地方法栈中 JNI 引用的对象
-   JVM 内部引用，如基本数据类型对应的 Class 对象，一些长驻的异常对象（NPE OOM 等），以及类加载器。
-   所有被同步锁（synchronized 关键字）持有的对象
-   JMXBean、JVMTI 中的回调、本地代码缓存等

## 分代假说
研究人员发现，Java对象的生命周期符合如下3个假说：
-   弱分代假说（Weak Generational Hypothesis）：绝大多数对象是朝生夕灭的
-   强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡
-   跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说是极少的

以上几个分代假说，奠定了多款常用的垃圾收集器的设计原则：
- 收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。
- 在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，同时能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。
- 跨代引用是极少的，因此没必要在新生代垃圾回收时扫描整个老年代，只需建立一个全局的数据结构 记忆集（Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。

## 清除算法

### 标记-清除

最基础的 GC 算法是「**标记-清除**」（Mark-Sweep）。分为「标记」、「清除」两个阶段。首先标记出所有需要回收的对象，然后统一回收。标记过程之前已经讲过了。

如图：

![](/1684076602032-1f2caced-02d9-457c-be30-023a422f1b10.webp)

缺点：内存空间碎片化，如果无法给一个大对象分配足够空间，JVM 会提前触发 Full GC。

### 标记-复制

**标记-复制**（mark-copying）算法将内存分为两块。若一块内存用毕，就对这块区域进行一次垃圾收集，将还存活的对象复制到另一块区域上。每次只使用一块，并将另一块内存保留。

![](/1684076954041-0dc4d60d-237d-4a3a-9a6e-7da07382fc74.webp)

相较于标记-清除算法，标记-复制的算法的优点是不会产生碎片。但他的缺点也很明显：有额外的复制开销，并且内存利用率最多只有50%。

回想一下分代假设：1. 大多数对象朝生夕灭；2. 熬过越多次 GC 的对象，越难以消亡。

对于新生代中的对象，由于其朝生夕灭的特性，就非常适合 Mark-Copy 算法。

现代JVM中，还对Mark-Copy进行了优化，将新生代分为较大的一块 Eden 和两块 Survivor。分配时使用 Eden 和一块 Survivor。GC 时，将 Eden 和其中一块 Survivor 内存区域中的存活对象，复制到另一块 Survivor 空间上。HotSpot VM 默认的比例为 Eden:Survivor=8:1 。也就是说，只有 10%的内存会被浪费（因为有两块 Survivor，最终比例是 8:1:1）。

### 标记-整理

对于老年代，对象存活率较高，较多的复制操作会导致性能下降，此时就不适用标记-复制算法了。

针对老年代特征，可以使用**标记-整理**（Mark-Compact）算法。其标记过程和"标记-清除"算法一样，但后续不是清理可回收对象，而是直接让所有存活对象都向一端移动，直接清理掉端边界外的内存。

![](/1684076667160-024c7348-db86-47f5-ae7a-c7e3ccdf259d.webp)

然而，移动存活对象的代价是很高的，尤其是老年代这种大区块。移动存活对象并更新引用是一项沉重、耗时的操作，必须停止整个程序 stop the world。 极大影响程序的**响应速度**。

# 垃圾收集器

分代收集算法概念：根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为新生代、老年代和永久代，并根据各个年代的特点分别采用不同的GC算法。

这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。根据系统可接受的停顿时间，每次都快速回收若干个小区域，从而减少一次GC所产生的的停顿时间，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。

|  分代   | 适用算法  | 特点|
|  ----  | ----  |----  |
| 新生代  | 标记-复制算法 |对象生命周期短，标记阶段会标记大量已死亡对象
| 老年代  | 标记-整理算法 |生命周期长的对象、大对象，可回收数量少 |
| 永久代  | 回收废弃的常量、无用的类 |存储Class类、常量、方法描述等 |


![](/1684160904333-0fde3ca6-d2a2-4c44-9361-631f79be278f.png)

### Serial收集器（新生代）

- 客户端模式下的默认新生代收集器；
- 简单而高效，额外的内存消耗最小；
- 可以管理较小内存（几十兆到一两百兆内存）

![](/1657553548237-5ba2fb2c-4bb6-4183-ab53-697372f3bf75.png)

### Serial Old收集器（老年代）

单线程的老年代垃圾回收器。

![](/1657553682670-d4ab211f-97eb-4ce6-97e2-bc0aa1631632.png)

### Parallel Scavenge收集器（新生代）

- 新生代收集器；
- 基于标记–复制算法的收集器；
- 并行收集的多线程收集器；
- 可控制吞吐量的收集器。

这款垃圾回收器又被称为吞吐量优先收集器。适用于跑批应用，不用太在乎单次STW卡顿时间，只要能够尽可能得利用CPU资源跑完程序就好。

$$ 吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间} $$

-  -XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间；该参数允许的值是一个大于 0 的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值；

-  -XX:GCTimeRatio：直接设置吞吐量大小，该参数的值是一个大于 0 小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为 19，那允许的最大垃圾收集时间就占总时间的 5%（即1/(1+19)），默认值为 99，即允许最大 1%（即1/(1+99)）的垃圾收集时间。

-  -XX:+UseAdaptiveSizePolicy：开启自适应调节策略，当这个参数被激活之后，就不需要人工一些参数细节了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

### ParNew收集器（新生代）

多线程并行版的Serial新生代垃圾回收器。除了 Serial 收集器外，目前只有 ParNew 能与 CMS 收集器配合工作。

![](/1657553579114-0754ec31-b112-4cc1-86ea-5781bc11ecd8.png)

### Parallel Old收集器（老年代）

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。

![](/1657553744602-35378cd9-f192-48bb-99ac-7f71d4420a33.png)

### CMS（ConcurrentMarkSweep）收集器（老年代）

比并发的老年代收集器Parallel Old又在进步一些，追求垃圾回收期间与用户程序并发、且低延迟，适合用在面向互联网用户的服务器应用。

垃圾收集算法是标记-清除，清除不会造成STW，所以优化点是标记，用到前面讲到的办法将标记过程拆细，分为初始标记（卡顿）、并发标记（无需卡顿）、二次标记（卡顿），初始标记、二次标记虽然卡顿但时间都很短。

CMS 垃圾收集四个步骤：

- 初始标记（CMS initial mark）：Stop The World，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；

- 并发标记（CMS concurrent mark）：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；

- 重新标记（CMS remark）：Stop The World，重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；

- 并发清除（CMS concurrent sweep）：并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。


![](/1657813406293-1cd958b5-a4b0-4f52-b913-40b75fe35696.png)

CMS 垃圾收集器不足：

**1）虽然可以并发进行标记、清理减少卡顿，但是多线程并行会消耗机器资源导致用户程序变慢，吞吐量降低。**

使用这款垃圾回收器要注意CPU核数的选择：CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。**但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。**如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。

**2）CMS 垃圾收集器无法处理“浮动垃圾（Floating Garbage）**

跟其他垃圾回收器不一样，不能等到老年代满了才进行垃圾回收了，因为回收过程中与用户线程并发，用户线程会产生新的对象，因此有一个参数（-XX：CMSInitiatingOccupancyFraction）控制老年代占用内存比例到达多少时触发垃圾回收，默认值是92%。如果并发期间分配对象还是失败，就会触发一次兜底的Serial Old。

**3）基于标记–清除算法实现，会产生内存碎片。**
-XX:+UseCMS-CompactAtFullCollection：在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程；
-XX:CMSFullGCsBefore-Compaction：这个参数的作用是要求 CMS 收集器在执行过若干次（数量由参数值决定）不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。

如果多次标记-清除，内存碎片太多无法找到足够大的连续空间分配对象，就会触发一次带内存碎片整理的Full GC（- XX：+ UseCMS-CompactAtFullCollection参数控制Full GC前是否需要内存整理，默认开启。

### G1收集器（混合代）
一个收集器就可以搞定整个内存的垃圾回收，不需要配置两个新生代和老年代的垃圾回收器了，因为内存布局跟原来完全不一样了，新生代和老年代粒度变小了，如下图，这种方式叫基于Region的内存布局，每个Region大小相等。

![](/1657849044831-805135b8-6c89-42b9-a6b0-3cee345aeae4.png)

这么设计有什么好处？

和垃圾回收器G1（Garbage First）的命名相关，追求的目标是固定一个延迟时间，不再区分回收新生代还是老年代，而是回收价值最大（能够回收最多内存的的区域），Garbage First可以叫回收效益排名第一的垃圾回收器。

关键参数- XX：MaxGCPauseMillis，默认值是200ms，核心的实现思路是建议停顿预测模型，即记录回收每个Region可能需要耗费的时间。

每次回收的过程跟CMS差不多，不过用的是标记-复制。

1）初始标记(Initial Marking)：会卡顿

2）并发标记（Concurrent Marking）

3）最终标记（Final Marking）：会卡顿

4）筛选回收（Live Data Counting and Evacuation)：回收价值最高的Region，用复制算法，会卡顿

# 启示和展望

在云原生浪潮席卷的今天，软件环境已经发生了天翻地覆的变化，不由让我们思考这样一个问题：我们是否还需要JVM? 我们是否真的还需要平台无关性？

将在的Java JVM 和 浏览器的v8引擎 进行比较，可以很明显的发现，我们不再需要客户端了，也不再需要平台无关性了，服务端的一切我们都是可控的。在这种背景下，GraalVM应运而生。

# ref

深入理解Java虚拟机 [https://book.douban.com/subject/34907497/](https://book.douban.com/subject/34907497/)

jvm参数生成及工具指引 [https://render.alipay.com/p/s/jvm-generate/JvmGenerate](https://render.alipay.com/p/s/jvm-generate/JvmGenerate)

jvm在线诊断 [https://arthas.aliyun.com/](https://arthas.aliyun.com/)

gc日志在线分析 [https://gceasy.io/](https://gceasy.io/)

[https://www.yuque.com/belber/archive/bhgel2?#QWTJx](https://www.yuque.com/belber/archive/bhgel2?#QWTJx)