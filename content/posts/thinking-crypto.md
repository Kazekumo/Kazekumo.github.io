---
title: "密码学漫谈"
date: "2023-05-20"
description: "浅浅分析一下"
tags: ["crypto"]
ShowToc: false
ShowBreadCrumbs: true
---


密码学的目的在于保护信息的安全性。

密码学通常关注以下性质的研究：
- 机密性：不将信息泄露给第三方
- 完整性：信息传递时，信息不被篡改，或在篡改后能够被迅速发现
- 可认证性：消息来源和消息本身是可认证的，而非伪造的
- 不可否认性：用户无法在事后否认曾经进行信息的生成，签发，接收行为

当然，对于开发人员来说，更关注加密工具的使用，因此下文介绍一些密码学常见原语，让阅读人员能有一个感性的认知。
# 机密性
## 对称加密
![](/Pasted%20image%2020230521011613.png)
对称加密(Symmetric Encryption)指的是加密和解密都使用同一个密钥。

消息发送者，发送信息传递前先进行加密。接受者收到消息后先进行解密。

对称加密建立在这样一个假设下：
> 在消息传递前，通信双方已通过其他可靠方式共享了密钥(secretKey)

对称加密不仅简单，而且加密效率高。但是问题在于通信双方如何共享一个密钥，而不泄露给第三方。常见的对称加密算法有 DES, AES 等。
## 非对称加密
非对称加密(Asymmetric Cryptography)，如它的名字一样，和对称加密相比，它最显著的区别在于加解密使用的不是同一个密钥。

非对称加密中，密钥成对出现，有公钥(public key)和私钥(private key)的区别。并且通信双方并不共享同一密钥，而是使用对方的公钥进行加密，自己的私钥进行解密。

以甲乙双方为例，通信过程如下:
1. 甲使用乙的公钥对消息1进行加密，并发送给乙；
2. 乙使用自己的私钥进行解密，获得消息明文；
3. 乙使用甲的公钥对消息2进行加密，并发送给甲；
4. 甲使用自己的私钥进行解密，获得消息明文。

常见的非对称加密算法有RSA、Elgamal、ECC算法等。

非对称加密的假设更加复杂，通信双方需要提前共享对方的公钥才可以安全通信，并且非对称加密的性能比对称加密要差得多。

但是算法的提出一定尤其背后的意义，这里介绍一下DH算法。

### Diffie-Hellman算法
上面提到，对称加密假设通信双方已经共享同一个密钥。DH算法便是用来使通信双方在不可信信道中共享密钥的。

假设甲乙双方需要传递密钥，他们之间可以这么做：
1.  甲首先选择一个素数`p`，例如97，底数`g`是`p`的一个原根，例如5，随机数`a`，例如123，然后计算`A=g^a mod p`，结果是34，然后，甲发送`p＝97`，`g=5`，`A=34`给乙；
2.  乙方收到后，也选择一个随机数`b`，例如，456，然后计算`B = g^b mod p`，结果是75，乙再同时计算`s = A^b mod p`，结果是22；
3.  乙把计算的`B=75`发给甲，甲计算`s ＝ B^a mod p`，计算结果与乙算出的结果一样，都是22。

原理解释：

对于甲的密钥计算过程有：
`s1 = B^a mod p = (g^b mod p)^a mod p = g^(b*a) mod p`

对于乙的密钥计算过程有：
`s2 = A^b mod p = (g^a mod p)^b mod p = g^(a*b) mod p`

根据乘法交换律，`s1 == s2`

在这个过程中，甲乙双方就达成了共享密钥s的目的。

第三方只能知道`p=97，g=5，A=34，B=75`，由于不知道双方选的秘密整数`a=123`和`b=456`，因此无法计算出密钥。

DH算法的安全性建立在离散对数问题上，通俗来讲就是对于一种运算，正向计算的成本和逆向运算的成本极其不对等。

比如对于上文提到的 `A=g^a mod p` ，对于甲来说，已知g、a和p，计算A是简单的。而对于第三方来说，已知g、A和p，计算a是困难的。

如果我们把`a`看成甲的私钥，`A`看成甲的公钥，`b`看成乙的私钥，`B`看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并

根据自己的私钥和对方的公钥，生成最终的密钥`secretKey`，DH算法通过数学定律保证了双方各自计算出的`secretKey`是相同的。

## 同态加密
同态加密（Homomorphic Encryption）是一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果。

这里的同态和代数上的同态是等价的。

如果定义一个运算符`*`，对加密算法 `E` ，满足：`E(x*y)=E(x)*E(y)`

通常的加密方案一般关注的是数据存储安全，也就是说在数据传输或存储过程中，没有密钥的用户，不可能从加密结果中得到有关原始数据的任何信息。只有拥有密钥的用户才能够正
确解密，得到原始的内容。我们注意到，这个过程中用户是不能对加密结果做任何操作的，只能进行存储、传输。对加密结果做任何操作，都将会导致错误的解密，甚至解密失败。

同态加密方案最有趣的地方在于，其关注的是数据处理安全。同态加密提供了一种对加密数据进行处理的功能。也就是说，其他人可以对加密数据进行处理，但是处理过程不会泄露任何原始内容。同时，拥有密钥的用户对处理过的数据进行解密后，得到的正好是处理后的结果。

## 隐写术
通常的加密算法目的是隐藏信息的涵义，而隐写术的目的是隐藏信息的存在。

比如我们可以在一张图片的二进制末尾追加内容，或是对图片的特定二进制位进行编码，当你正常打开图片时，肉眼无法感知到不同。但是只要你知道编码规则，那么就可以从图片中还原出隐藏的信息。

# 完整性
## 哈希函数
哈希函数（Hash function）又称摘要函数、散列函数，能够将任意长度的输入值转变成固定长度的值输出，该值称为哈希值或散列值，输出值通常为字母与数字组合。

哈希函数对扰动是敏感的，也就是说原始信息更改哪怕一个字节，哈希计算的结果都会完全不同。

哈希函数可被用来生成"摘要"来作完整性校验，或者用来存储密码。

安全的哈希函数通常需要具备以下性质
1. 原像稳固: 给定一个Hash值 y，很难找到一个 x，使得 y=h(x)
2. 第二原像稳固: 给定一个 x，很难找到另一个值 x’，使得 h(x)=h(x’)
3. 碰撞稳固: 很难找到一对值 x 和 x’ (x≠x’)，使得 h(x)=h(x’)

常见的哈希函数有 MD5，SHA-1，SHA-2等。

网上说的MD5和SHA-1不再安全，指的都是其碰撞稳固性被打破，而不是第二原像性被打破。

对于哈希函数，黑客通常会使用彩虹表的方式进行攻击，如[MD5解密](https://www.cmd5.com/)，也就是通过穷举字符组合，存储了明文密文的映射关系。

大多数用户在不同的网站或应用中使用相同的密码，当一个网站的数据库被盗取，存储的密码就会被攻击者获取。因此，在存储密码时，不应该直接存储，而应该存储哈希值，并且计算前要加盐避免彩虹表攻击。除此以外，还可以考虑慢哈希函数等。

# 可认证性及不可否认性
## 中间人攻击
上文的加密算法中，虽然已经实现了通信双方可以在不可信信道中共享密钥，来实现加密通信的目的。但是其实还有一个隐藏假设，那就是攻击者只可以监听信道，而不可以篡改信道中的消息。
![](/Pasted%20image%2020230521033838.png)
当攻击者可以篡改信息时，所有的安全性都化为泡影。攻击者只需要在信道中扮演另一方的身份来进行密钥的交换，对于通信双方来说根本无法察觉。

在这种情况下，我们只能呼叫场外援助(数字证书)了。

## 数字签名
数字签名类似现实世界中的签名和盖章，数字签名是一种能防止用户抵赖，伪装，篡改和否认的密码技术。

对于要签名的信息，签名者先使用哈希函数计算其摘要，然后使用对摘要使用私钥进行加密。

验签者接收到信息后，使用签名者的公钥进行解密，然后对信息同样计算其摘要。如果两个摘要是相同的，那么就说明该消息没有被篡改。

目前广泛使用的数字签名算法包括 RSA、ElGamal、DSA、ECDSA等。

## 数字证书
![](/Pasted%20image%2020230521034511.png)
最简单的证书包含一个**公钥、名称以及证书授权中心(Certificate Authority)的数字签名**。一般情况下证书中还包括密钥的有效期，颁发者（证书授权中心）的名称，该证书的序列号等信息，证书的结构遵循X.509 v3版本的规范。

点击一下浏览器网址中的小锁，就可以看到网站的证书了。
![](/Pasted%20image%2020230521040045.png)
在TLS握手过程中，服务端会发送自己的数字证书，可以看到证书的结构是分层级的，为 GTS Root R1 -> GTS CA 1C3 -> www.google.com

对客户端来说，网页证书并不可靠，但是它被二级CA机构签发了，那么二级CA可不可靠呢，也不可靠，但是二级CA被根CA机构签发了。

由于我们的电脑中都预装了根CA证书，我们可以通过根CA公钥验证数字签名，因此二级证书也是可靠的；由此，网站也是可靠的。

可见，数字证书体系的本质是信任的传导。
# 总结

![](/Pasted%20image%2020230521041154.png)


# ref
https://halfrost.com/cryptography_overview
维基百科