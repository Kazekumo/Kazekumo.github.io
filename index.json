[{"content":"软件开发就是在解决问题。那问题一般是如何解决的呢？\n最常见的解决问题思路是分而治之，也就是说，我们要先把问题拆分开。在每个问题都得到解决之后，再把这些解决好的子问题以恰当的方式组装起来。\n如何分解与组合，就是我们要在软件设计中考虑的问题。\n大部分人都把焦点放在了如何组合上，却忽略了至关重要的第一步：分解。\n以这段代码为例\n1 2 3 4 5 6 7 EpubStatus status = null; CreateEpubResponse response = createEpub(request); if (response.getCode() == 201) { status = EpubStatus.CREATED; } else { status = EpubStatus.TO_CREATE; } 绝大多数程序复杂混乱的根本原因：业务逻辑与控制逻辑的耦合。\n关注点分离（Separation of concerns，SoC）是将计算机程序分隔为不同部分的设计原则。\n以分离功能点为例，我们通常会进行树形的思考，进行流程性的拆分。 分离的方式有很多，除了流程的拆分，还有以下的形式：\n前后分离：客户端与服务端分离 动静分离：把变和不变的内容分离 读写分离：把读和写分离 冷热分离：把低频和高频的分离 封装、多态：行为与实现的分离、变与不变的分离 \u0026hellip; 下面简单的介绍一些编程范式，思考这些编程范式是如何进行抽象化拆分的。\n编程范式 \u0026ldquo;编程范式\u0026quot;是一种编程思想的总称，它是指在编写程序时所采用的基本方法和规范。\n这里介绍一些常见的范式。\n命令式编程 命令式编程由一组详细的指令组成，让计算机以一定的顺序执行。之所以被称作“命令式”是因为开发者以非常具体的方式，准确地规定计算机必须做什么。\n假如你想烤一个蛋糕，命令式编程的制作方式如下\n1 2 3 4 5 6 7 8 9 function makeCake() { 1- 将面粉倒入碗中 2- 在碗中打入两个鸡蛋 3- 倒入一些牛奶 4- 将它们混合 5- 将混合物倒入模具 6- 烤35分钟 7- 冷却 } 若使用真实的代码，假设我们想要从一个数组中过滤出大于5的所有元素，命令式编程如下：\n1 2 3 4 5 6 7 8 const nums = [1,4,3,6,7,8,9,2] const result = [] for (let i = 0; i \u0026lt; nums.length; i++) { if (nums[i] \u0026gt; 5) result.push(nums[i]) } console.log(result) // 输出: [ 6, 7, 8, 9 ] 我们的指令非常的具体详尽，这就是命令式编程的特点。\n过程式编程 在过程式编程中，开发者被鼓励将程序的执行拆分成不同的函数，以此来提高程序的模块化和组织性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function pourIngredients() { - 将面粉倒入碗中 - 在碗中打入两个鸡蛋 - 倒入一些牛奶 } function mixAndTransferToMold() { - 将它们混合 - 将混合物倒入模具 } function cookAndLetChill() { - 烤35分钟 - 冷却 } function makeCake(){ pourIngredients() // 倒入配料 mixAndTransferToMold() // 混合材料 cookAndLetChill() // 烤制并冷却 } 虽然看起来只是拆分成了子过程，其实已经可以极大程度的减轻开发者的心智负担。\n毕竟实际代码中，命令式编程长这样 函数式编程 组合性 在函数式编程中，有一类比较特殊的函数，它们可以接收函数作为输入，或者返回一个函数作为输出。这种函数叫做高阶函数（High-order function）。\n高阶函数有什么用呢？它的一个重要作用在于，我们可以用它去做行为的组合。\n在业务流程中，数据经过一系列的列表转换会得到一个结果： 最基础的列表转换有三种典型模式，分别是 map、filter 和 reduce。\n假设我们想要从一个数组中过滤出大于5的所有元素的和, 函数式编程如下\n1 2 3 const nums = [1,4,3,6,7,8,9,2] console.log(nums.filter(num =\u0026gt; num \u0026gt; 5).reduce((x,y)=\u0026gt;x+y,0)) 从某种程度上来说，函数式编程分离了控制流与数据流。同时控制流可以进行灵活的组合。\n不变性 函数式编程的不变性主要体现在值和纯函数上。\n值，可以将它理解为一个初始化之后就不再改变的量。 纯函数，是符合下面两点的函数：\n对于相同的输入，给出相同的输出； 没有副作用。 值保证不会显式改变一个量，而纯函数保证的是，不会隐式改变一个量。\n以java中一个常见的错误为例:\n1 2 3 4 5 6 7 class Sample { private static final DateFormat format = new SimpleDateFormat(\u0026#34;yyyy.MM.dd\u0026#34;); public String getCurrentDateText() { return format.format(new Date()); } } 这段代码在多线程环境下就会出问题，就像下面这张图看到的：\nA 线程把变量的值修改成自己需要的值； 这时发生线程切换，B 线程开始执行，将变量的值修改成它所需要的值； 线程切换回来，A 线程继续执行，但此时变量已经不是自己设置的值了，所以，执行会出错。 编写纯函数的重点是，不修改任何字段，也不调用修改字段内容的方法。\n1 String replace(char oldChar, char newChar); 面向对象 函数式编程就是把一些功能或逻辑代码通过函数拼装方式来组织的玩法。这其中涉及最多的是函数，也就是编程中的代码逻辑。但代码中还是需要处理数据的，这些就是所谓的“状态”。函数式编程需要我们写出无状态的代码，但我们终究是要处理状态的，这就是面向对象的内容。\n封装：构建模型，组合模块，隐藏细节 继承：is-a 关系，代码复用 多态：提高拓展性，不关注子类实现\n面向对象中我们通常依赖接口而不是实现，接口是对逻辑的抽象，把真正的逻辑放在不同的具体类中，通过多态或是依赖注入这样的控制来完成对数据在不同情况下的不同处理。\n声明式编程 声明式编程（Declarative Programming）是一种关注描述问题逻辑和规则的编程范式。\n在声明式编程中，我们通过声明所需的结果和约束条件，让计算机自行推导出解决方案，而不需要明确指定每个步骤的执行细节。\n命令式代码是在说明怎么做（How），而声明式代码则是在说做什么（What）；\njava中常见的注解、SQL语句，甚至DSL，实际上就是声明式编程。\n1 2 3 4 @Transactional public void test() { // 事务操作 } 1 SELECT * FROM posts WHERE user_id = 1 AND title LIKE \u0026#39;hello%\u0026#39;; 声明式编程只是描述最终的目标，而不关系具体的步骤，将表达与运行进行了分离。\n指令-\u0026gt;函数-\u0026gt;对象-\u0026gt;声明 ，是从细节走向了抽象，处于了不同层次，是复杂现实到简单理想的过度\nref 极客时间-软件设计之美、左耳听风\n关注点分离\n程序员必须要知道的编程范式\n从可逆计算看声明式编程\n","permalink":"https://Kazekumo.github.io/posts/code-styles/","summary":"软件开发就是在解决问题。那问题一般是如何解决的呢？ 最常见的解决问题思路是分而治之，也就是说，我们要先把问题拆分开。在每个问题都得到解决之后，","title":"从常见编程范式看关注点的分离"},{"content":"密码学的目的在于保护信息的安全性。\n密码学通常关注以下性质的研究：\n机密性：不将信息泄露给第三方 完整性：信息传递时，信息不被篡改，或在篡改后能够被迅速发现 可认证性：消息来源和消息本身是可认证的，而非伪造的 不可否认性：用户无法在事后否认曾经进行信息的生成，签发，接收行为 当然，对于开发人员来说，更关注加密工具的使用，因此下文介绍一些密码学常见原语，让阅读人员能有一个感性的认知。\n机密性 对称加密 对称加密(Symmetric Encryption)指的是加密和解密都使用同一个密钥。\n消息发送者，发送信息传递前先进行加密。接受者收到消息后先进行解密。\n对称加密建立在这样一个假设下：\n在消息传递前，通信双方已通过其他可靠方式共享了密钥(secretKey)\n对称加密不仅简单，而且加密效率高。但是问题在于通信双方如何共享一个密钥，而不泄露给第三方。\n常见的对称加密算法有 DES, AES 等。\n非对称加密 非对称加密(Asymmetric Cryptography)，如它的名字一样，和对称加密相比，它最显著的区别在于加解密使用的不是同一个密钥。\n非对称加密中，密钥成对出现，有公钥(public key)和私钥(private key)的区别。并且通信双方并不共享同一密钥，而是使用对方的公钥进行加密，自己的私钥进行解密。\n以甲乙双方为例，通信过程如下:\n甲使用乙的公钥对消息1进行加密，并发送给乙； 乙使用自己的私钥进行解密，获得消息明文； 乙使用甲的公钥对消息2进行加密，并发送给甲； 甲使用自己的私钥进行解密，获得消息明文。 常见的非对称加密算法有RSA、Elgamal、ECC算法等。\n非对称加密的假设更加复杂，通信双方需要提前共享对方的公钥才可以安全通信，并且非对称加密的性能比对称加密要差得多。\n但是算法的提出一定尤其背后的意义，这里介绍一下DH算法。\nDiffie-Hellman算法 上面提到，对称加密假设通信双方已经共享同一个密钥。DH算法便是用来使通信双方在不可信信道中共享密钥的。\n假设甲乙双方需要传递密钥，他们之间可以这么做：\n甲首先选择一个素数p，例如97，底数g是p的一个原根，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是34，然后，甲发送p＝97，g=5，A=34给乙； 乙方收到后，也选择一个随机数b，例如，456，然后计算B = g^b mod p，结果是75，乙再同时计算s = A^b mod p，结果是22； 乙把计算的B=75发给甲，甲计算s ＝ B^a mod p，计算结果与乙算出的结果一样，都是22。 原理解释：\n对于甲的密钥计算过程有： s1 = B^a mod p = (g^b mod p)^a mod p = g^(b*a) mod p\n对于乙的密钥计算过程有： s2 = A^b mod p = (g^a mod p)^b mod p = g^(a*b) mod p\n根据乘法交换律，s1 == s2\n在这个过程中，甲乙双方就达成了共享密钥s的目的。\n第三方只能知道p=97，g=5，A=34，B=75，由于不知道双方选的秘密整数a=123和b=456，因此无法计算出密钥。\nDH算法的安全性建立在离散对数问题上，通俗来讲就是对于一种运算，正向计算的成本和逆向运算的成本极其不对等。\n比如对于上文提到的 A=g^a mod p ，对于甲来说，已知g、a和p，计算A是简单的。而对于第三方来说，已知g、A和p，计算a是困难的。\n如果我们把a看成甲的私钥，A看成甲的公钥，b看成乙的私钥，B看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并\n根据自己的私钥和对方的公钥，生成最终的密钥secretKey，DH算法通过数学定律保证了双方各自计算出的secretKey是相同的。\n同态加密 同态加密（Homomorphic Encryption）是一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果。\n这里的同态和代数上的同态是等价的。\n如果定义一个运算符*，对加密算法 E ，满足：E(x*y)=E(x)*E(y)\n通常的加密方案一般关注的是数据存储安全，也就是说在数据传输或存储过程中，没有密钥的用户，不可能从加密结果中得到有关原始数据的任何信息。只有拥有密钥的用户才能够正 确解密，得到原始的内容。我们注意到，这个过程中用户是不能对加密结果做任何操作的，只能进行存储、传输。对加密结果做任何操作，都将会导致错误的解密，甚至解密失败。\n同态加密方案最有趣的地方在于，其关注的是数据处理安全。同态加密提供了一种对加密数据进行处理的功能。也就是说，其他人可以对加密数据进行处理，但是处理过程不会泄露任何原始内容。同时，拥有密钥的用户对处理过的数据进行解密后，得到的正好是处理后的结果。\n隐写术 通常的加密算法目的是隐藏信息的涵义，而隐写术的目的是隐藏信息的存在。\n比如我们可以在一张图片的二进制末尾追加内容，或是对图片的特定二进制位进行编码，当你正常打开图片时，肉眼无法感知到不同。但是只要你知道编码规则，那么就可以从图片中还原出隐藏的信息。\n完整性 哈希函数 哈希函数（Hash function）又称摘要函数、散列函数，能够将任意长度的输入值转变成固定长度的值输出，该值称为哈希值或散列值，输出值通常为字母与数字组合。\n哈希函数对扰动是敏感的，也就是说原始信息更改哪怕一个字节，哈希计算的结果都会完全不同。\n哈希函数可被用来生成\u0026quot;摘要\u0026quot;来作完整性校验，或者用来存储密码。\n安全的哈希函数通常需要具备以下性质\n原像稳固: 给定一个Hash值 y，很难找到一个 x，使得 y=h(x) 第二原像稳固: 给定一个 x，很难找到另一个值 x’，使得 h(x)=h(x’) 碰撞稳固: 很难找到一对值 x 和 x’ (x≠x’)，使得 h(x)=h(x’) 常见的哈希函数有 MD5，SHA-1，SHA-2等。\n网上说的MD5和SHA-1不再安全，指的都是其碰撞稳固性被打破，而不是第二原像性被打破。\n对于哈希函数，黑客通常会使用彩虹表的方式进行攻击，如MD5解密，也就是通过穷举字符组合，存储了明文密文的映射关系。\n大多数用户在不同的网站或应用中使用相同的密码，当一个网站的数据库被盗取，存储的密码就会被攻击者获取。因此，在存储密码时，不应该直接存储，而应该存储哈希值，并且计算前要加盐避免彩虹表攻击。除此以外，还可以考虑慢哈希函数等。\n可认证性及不可否认性 中间人攻击 上文的加密算法中，虽然已经实现了通信双方可以在不可信信道中共享密钥，来实现加密通信的目的。但是其实还有一个隐藏假设，那就是攻击者只可以监听信道，而不可以篡改信道中的消息。 当攻击者可以篡改信息时，所有的安全性都化为泡影。攻击者只需要在信道中扮演另一方的身份来进行密钥的交换，对于通信双方来说根本无法察觉。\n在这种情况下，我们只能呼叫场外援助(数字证书)了。\n数字签名 数字签名类似现实世界中的签名和盖章，数字签名是一种能防止用户抵赖，伪装，篡改和否认的密码技术。\n对于要签名的信息，签名者先使用哈希函数计算其摘要，然后使用对摘要使用私钥进行加密。\n验签者接收到信息后，使用签名者的公钥进行解密，然后对信息同样计算其摘要。如果两个摘要是相同的，那么就说明该消息没有被篡改。\n目前广泛使用的数字签名算法包括 RSA、ElGamal、DSA、ECDSA等。\n数字证书 最简单的证书包含一个公钥、名称以及证书授权中心(Certificate Authority)的数字签名。一般情况下证书中还包括密钥的有效期，颁发者（证书授权中心）的名称，该证书的序列号等信息，证书的结构遵循X.509 v3版本的规范。\n点击一下浏览器网址中的小锁，就可以看到网站的证书了。 在TLS握手过程中，服务端会发送自己的数字证书，可以看到证书的结构是分层级的，为 GTS Root R1 -\u0026gt; GTS CA 1C3 -\u0026gt; www.google.com\n对客户端来说，网页证书并不可靠，但是它被二级CA机构签发了，那么二级CA可不可靠呢，也不可靠，但是二级CA的证书被根CA机构签发了。\n由于我们的电脑中都预装了根CA证书，我们可以通过根CA公钥验证数字签名，因此二级证书也是可靠的；由此，网站也是可靠的。\n数字证书的假设是：根CA及其证书是可靠有效的。\n可见，数字证书是一种基于数字签名的信任传导机制。\n总结 ref https://halfrost.com/cryptography_overview\n维基百科\n","permalink":"https://Kazekumo.github.io/posts/thinking-crypto/","summary":"密码学的目的在于保护信息的安全性。 密码学通常关注以下性质的研究： 机密性：不将信息泄露给第三方 完整性：信息传递时，信息不被篡改，或在篡改后能够","title":"密码学漫谈"},{"content":"为什么有JVM 在学习JVM(Java Virtual Machine)之前，大家可以先思考一个问题，为什么我们需要JVM\n以上图为例，cpp开发的软件具备一个明显劣势，那就是他无法满足跨平台的需求(一次编写，处处编译)\n计算机领域有一句名言：\n计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.\nJVM便是通过增加中间层实现了\u0026quot;一次编译，处处运行\u0026quot;\nJVM能做什么 平台无关性: 通过class文件将程序和机器环境进行解耦，运行时再翻译成机器码 语言无关性: JVM不与Java等任何程序语言进行绑定，只要是符合标准的class文件都可以运行在JVM上 JVM运行机制 垃圾回收算法 除了上面的跨平台性，Java 和 cpp相比，还有一个显著的区别，那就是内存动态分配和垃圾回收。\n对于GC(Garbage Collection)，我们需要考虑2个问题：\n哪些内存需要回收? 如何回收? 程序计数器、虚拟机栈、本地方法栈 3 个区域是 Thread Local 的，随线程而生，随线程而灭，不用过多关心如何回收的问题。\n然而 Heap 和方法区有显著的不确定性，这部分内存更是实际中用得最多的内存，也因此诞生了许多分配与回收算法。\n引用计数 引用记数（Reference Counting）是最简单的一种收集方法，许多编程语言使用该方法管理内存（Objective-C、Swift 等）\n它的缺点和优势都很明显。它的判定效率高，占用低。然而需要程序员在编码时额外配合，必须手动将对象置空。\n除此之外，它无法解决循环引用问题。\n可达性分析 当一块内存永远不可能再被访问到时，他就应该被回收。\n如图所示，该算法的主要思路是把一系列被称作「GC Roots」的根对象作为起始节点，从这些节点开始往下搜索，搜索过的路径称作「引用链」（Reference Chain）。如果某个对象和 GC Roots 间没有引用链连接。就说明该对象不可达，也就不可能再被使用。\n在 JVM 中，可作为 GC Roots 的对象有以下几种：\nVM Stack 中引用的对象，如方法参数、局部变量、临时变量等。 在方法区内的静态属性对象 在方法去内常量引用的对象，如字符串常量池（String Table）中的引用 本地方法栈中 JNI 引用的对象 JVM 内部引用，如基本数据类型对应的 Class 对象，一些长驻的异常对象（NPE OOM 等），以及类加载器。 所有被同步锁（synchronized 关键字）持有的对象 JMXBean、JVMTI 中的回调、本地代码缓存等 分代假说 研究人员发现，Java对象的生命周期符合如下3个假说：\n弱分代假说（Weak Generational Hypothesis）：绝大多数对象是朝生夕灭的 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说是极少的 以上几个分代假说，奠定了多款常用的垃圾收集器的设计原则：\n收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。 在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，同时能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。 跨代引用是极少的，因此没必要在新生代垃圾回收时扫描整个老年代，只需建立一个全局的数据结构 记忆集（Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。 清除算法 标记-清除 最基础的 GC 算法是「标记-清除」（Mark-Sweep）。分为「标记」、「清除」两个阶段。首先标记出所有需要回收的对象，然后统一回收。\n如图：\n缺点：内存空间碎片化，如果无法给一个大对象分配足够空间，JVM 会提前触发 Full GC。\n标记-复制 标记-复制（mark-copying）算法将内存分为两块。若一块内存用毕，就对这块区域进行一次垃圾收集，将还存活的对象复制到另一块区域上。每次只使用一块，并将另一块内存保留。\n相较于标记-清除算法，标记-复制的算法的优点是不会产生碎片。\n但他的缺点也很明显：有额外的复制开销，并且内存利用率最多只有50%。\n回想一下分代假设：1. 大多数对象朝生夕灭；2. 熬过越多次 GC 的对象，越难以消亡。\n对于新生代中的对象，由于其朝生夕灭的特性，就非常适合 Mark-Copy 算法。\n现代JVM中，还对Mark-Copy进行了优化，将新生代分为较大的一块 Eden 和两块 Survivor。分配时使用 Eden 和一块 Survivor。GC 时，将 Eden 和其中一块 Survivor 内存区域中的存活对象，复制到另一块 Survivor 空间上。HotSpot VM 默认的比例为 Eden:Survivor=8:1 。也就是说，只有 10%的内存会被浪费（因为有两块 Survivor，最终比例是 8:1:1）。\n标记-整理 对于老年代，对象存活率较高，较多的复制操作会导致性能下降，此时就不适用标记-复制算法了。\n针对老年代特征，可以使用标记-整理（Mark-Compact）算法。其标记过程和\u0026quot;标记-清除\u0026quot;算法一样，但后续不是清理可回收对象，而是直接让所有存活对象都向一端移动，直接清理掉端边界外的内存。\n然而，移动存活对象的代价是很高的，尤其是老年代这种大区块。移动存活对象并更新引用是一项沉重、耗时的操作，必须停止整个程序 stop the world。 极大影响程序的响应速度。\n垃圾收集器 分代收集算法概念：根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为新生代、老年代和永久代，并根据各个年代的特点分别采用不同的GC算法。\n这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。根据系统可接受的停顿时间，每次都快速回收若干个小区域，从而减少一次GC所产生的的停顿时间，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。\n分代 适用算法 特点 新生代 标记-复制算法 对象生命周期短，标记阶段会标记大量已死亡对象 老年代 标记-整理算法 生命周期长的对象、大对象，可回收数量少 永久代 回收废弃的常量、无用的类 存储Class类、常量、方法描述等 除了分代收集算法外，还有分区收集算法，其特点是直接将堆内存分为多个大小相等的独立空间(Region)。\n衡量垃圾收集器的三个重要指标是：内存占用(Footprint)、吞吐量(Throught)和延迟(Latency)，三者共同构成了一个\u0026quot;不可能三角\u0026quot;，要同时在这三个方面具有卓越表现几乎是不可能的。因此垃圾回收器在设计时也会有所偏向。\nSerial收集器（新生代） 客户端模式下的默认新生代收集器； 简单而高效，额外的内存消耗最小； 可以管理较小内存（几十兆到一两百兆内存） Serial Old收集器（老年代） 单线程的老年代垃圾回收器。\nParNew收集器（新生代） 多线程并行版的Serial新生代垃圾回收器。除了 Serial 收集器外，目前只有 ParNew 能与 CMS 收集器配合工作。\nParallel Scavenge收集器（新生代） 新生代收集器； 基于标记–复制算法的收集器； 并行收集的多线程收集器； 可控制吞吐量的收集器。 这款垃圾回收器又被称为吞吐量优先收集器。适用于跑批应用，不用太在乎单次STW卡顿时间，只要能够尽可能得利用CPU资源跑完程序就好。\n$$ 吞吐量=\\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间} $$\n这款收集器有以下几个关键参数：\n-XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间；该参数允许的值是一个大于 0 的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值；\n-XX:GCTimeRatio：直接设置吞吐量大小，该参数的值是一个大于 0 小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为 19，那允许的最大垃圾收集时间就占总时间的 5%（即1/(1+19)），默认值为 99，即允许最大 1%（即1/(1+99)）的垃圾收集时间。\n-XX:+UseAdaptiveSizePolicy：开启自适应调节策略，当这个参数被激活之后，就不需要设置分区占比等参数细节了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。\nParallel Old收集器（老年代） Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。\nCMS收集器（老年代） CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它在垃圾回收期间和用户程序并发可以做到一定程度的并发，适合用在面向互联网用户的服务器应用。 该收集器基于标记–清除算法实现。\nCMS 垃圾收集四个步骤：\n初始标记（CMS initial mark）：Stop The World，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；\n并发标记（CMS concurrent mark）：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；\n重新标记（CMS remark）：Stop The World，重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；\n并发清除（CMS concurrent sweep）：并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\nCMS 垃圾收集器不足：\n1）对处理器资源敏感\nCMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。\n2）CMS 垃圾收集器无法处理“浮动垃圾（Floating Garbage）\n在CMS的并发标记和并发清理阶段，用户线程还在继续运行，用户线程会产生新的对象。由于这部分垃圾出现在标记过程结束之后，CMS无法在当次收集中处理掉它们，只好等待下一次垃圾回收再清理。并且由于CMS收集器会和用户线程并发，不能等老年代满了再进行收集，必须预留一部分空间给用户线程。因此有一个参数（-XX：CMSInitiatingOccu-pancyFraction）控制老年代占用内存比例到达多少时触发垃圾回收，默认值是92%。如果并发期间分配对象还是失败，就会触发一次兜底的Serial Old收集。\n3）基于标记–清除算法实现，会产生内存碎片。\nCMS是一款基于\u0026quot;标记-清除\u0026quot;算法实现的垃圾回收器，因此会产生大量的内存碎片，这将导致大对象的分配带来麻烦。因此CMS提供了如下参数进行碎片整理。 -XX:+UseCMS-CompactAtFullCollection：在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，该参数是默认开启的； -XX:CMSFullGCsBefore-Compaction：这个参数的作用是要求 CMS 收集器在执行过若干次（数量由参数值决定）不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。\nG1收集器（混合代） 之前的所讲述的收集器，垃圾回收的目标范围是整个新生代，要么是整个老年代，再要么是整个Java堆。而G1(Garbage First)收集器跳出了这个樊笼，它可以面向堆内存的任何部分进行回收，衡量标准不再是分代，而是哪块内存中存放的垃圾数量最多。\nG1把连续的堆内存划分为多个大小相等的独立区域(Region)，Region 的类型有 Eden、Survivor、Old、Humongous 四种。收集器对扮演不同角色的Region采用不同的策略去处理。\nG1收集器的核心思路是建立可靠的停顿预测模型(通过- XX：MaxGCPauseMillis，控制收集停顿时间，默认200ms)，跟踪各个Region中垃圾堆积的\u0026quot;价值\u0026quot;，优先处理回收价值收益最大的Region。其不追求一次清理所有垃圾，而是只要能够应付应用的内存分配速率(Allocation Rate)即可。\n启示和展望 限于篇幅，虽然本文叫做简介，却只讲了JVM主体架构和垃圾收集器，省略了许多有趣的内容，如类加载机制、类增强机制、编译时优化，运行时优化，内存分配机制等等。在阅读《深入理解Java虚拟机》的过程中，这些内容都一一得到阐释，也不由的感慨JVM设计的如此之好，以至于程序员们几乎感受不到他的存在。\n其实在使用Java的过程中，一直有一个疑问：在云原生浪潮席卷的今天，软件环境已然发生了天翻地覆的变化，和十数年前相比，服务端场景并不需要跨平台性，此时JVM究竟给我们带来的是性能的损耗，还是内存管理的便利性？\n在这种背景下, GraalVM 应运而生，这是一个在 HotSpot 虚拟机基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。\n或许有一天我们仍在写Java，却再也看不到JVM的踪影了。\nref 深入理解Java虚拟机 https://book.douban.com/subject/34907497/\njvm参数生成及工具指引 https://render.alipay.com/p/s/jvm-generate/JvmGenerate\njvm在线诊断 https://arthas.aliyun.com/\ngc日志在线分析 https://gceasy.io/\n如何用好Java虚拟机\n","permalink":"https://Kazekumo.github.io/posts/thinking-jvm/","summary":"为什么有JVM 在学习JVM(Java Virtual Machine)之前，大家可以先思考一个问题，为什么我们需要JVM 以上图为例，cpp开发的软件具备一个","title":"JVM简介"},{"content":"开发中发现许多对象都依赖了css的基类对象BaseEntity 偶然点开发现里面的写法不太容易理解，因此分析记录一下\n点开对象可以发现，有两个属性是比较特别的，也就是 propMap 和 visitor 本文的目的也主要是分析这两个对象的用途。\n先直接看这两个对象在哪用了，翻阅源码可以发现，两个属性的主要使用入口都在toString中。 最终这个函数是调用了toString0 或者 hexString 初见这一坨，我也百思不得其解，先不管，继续看看toString0 分析代码可知，toString0这个方法才是对象转字符串的主要实现，通过getProps获取对象的属性列表，然后在下面进行属性的拼接 看看getProps，可以发现propMap的用途是存储该类的所有属性名称。 如果该对象的属性未初始化，则通过反射获取。 需要注意的是，这里使用了 double check lock，避免重入。 当第二次进入时，就可以复用属性，不用再反射获取了。 到了此处，propMap 的用途基本就解答了。\n那么为啥要有 visotor 呢？我们再回过头来看toString方法 在toString方法中，visitor 的逻辑主要如下\n如果 visitor为空，重新初始化 visitor 如果 visitor.get() 为空： 1. 设置 visitor 为当前对象 2. 调用 toString0 3. 设置 visitor 为 null 如果 visitor 的值不为空，返回 HexString 这里的目的不太好理解。首先对于步骤1，我们可以先忽略，因为实际不影响流程。 控制流程的主要是步骤2和步骤3。 首先可以观察到，步骤2的进入条件是 visitor 为空，步骤3的进入条件为 visitor 不为空。也就是说，步骤2和步骤3这两步操作是互斥的。 在步骤2.1中，设置了 visitor 为当前对象，然后在2.3中又重置了回去。那么也就是说同一个线程，他不能重入步骤2。\n这里比较有迷惑性，因为threadLocal是线程独立的，搞这么复杂干嘛呢，同一个线程还能重入这个方法不成？ 读者可以先思考一下，表情包下面给出答案。\n同一个线程还能重入这个方法不成？确实是可能的。 答案就是当对象发生了循环引用，这时调用toString方法，序列化子对象时，由于循环引用，就会再次进入父对象的toString方法，不断套娃，最终导致栈溢出。 所以此处使用visitor进行流程控制的目的就是为了打破这个循环调用链。\n实际上，许多框架都支持了循环引用，不过方式上可能有些许差异，比如 FastJson 使用 $ref 占位符避免序列化子对象，Spring 使用了多级缓存的方式等等，这里就不赘述了。\n框架开发人员总是考虑到各种场景进行了兼容，不过我认为大部分循环引用，其实并不值得解决，因为其代表是层级结构本身的不合理。\n","permalink":"https://Kazekumo.github.io/posts/baseentity-analysis/","summary":"开发中发现许多对象都依赖了css的基类对象BaseEntity 偶然点开发现里面的写法不太容易理解，因此分析记录一下 点开对象可以发现，有两个属","title":"某基类的源码分析"}]