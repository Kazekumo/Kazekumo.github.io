[{"content":"密码学的目的在于保护信息的安全性。\n密码学通常关注以下性质的研究：\n机密性：不将信息泄露给第三方 完整性：信息传递时，信息不被篡改，或在篡改后能够被迅速发现 可认证性：消息来源和消息本身是可认证的，而非伪造的 不可否认性：用户无法在事后否认曾经进行信息的生成，签发，接收行为 当然，对于开发人员来说，更关注加密工具的使用，因此下文介绍一些密码学常见原语，让阅读人员能有一个感性的认知。\n机密性 对称加密 对称加密(Symmetric Encryption)指的是加密和解密都使用同一个密钥。\n消息发送者，发送信息传递前先进行加密。接受者收到消息后先进行解密。\n对称加密建立在这样一个假设下：\n在消息传递前，通信双方已通过其他可靠方式共享了密钥(secretKey)\n对称加密不仅简单，而且加密效率高。但是问题在于通信双方如何共享一个密钥，而不泄露给第三方。\n常见的对称加密算法有 DES, AES 等。\n非对称加密 非对称加密(Asymmetric Cryptography)，如它的名字一样，和对称加密相比，它最显著的区别在于加解密使用的不是同一个密钥。\n非对称加密中，密钥成对出现，有公钥(public key)和私钥(private key)的区别。并且通信双方并不共享同一密钥，而是使用对方的公钥进行加密，自己的私钥进行解密。\n以甲乙双方为例，通信过程如下:\n甲使用乙的公钥对消息1进行加密，并发送给乙； 乙使用自己的私钥进行解密，获得消息明文； 乙使用甲的公钥对消息2进行加密，并发送给甲； 甲使用自己的私钥进行解密，获得消息明文。 常见的非对称加密算法有RSA、Elgamal、ECC算法等。\n非对称加密的假设更加复杂，通信双方需要提前共享对方的公钥才可以安全通信，并且非对称加密的性能比对称加密要差得多。\n但是算法的提出一定尤其背后的意义，这里介绍一下DH算法。\nDiffie-Hellman算法 上面提到，对称加密假设通信双方已经共享同一个密钥。DH算法便是用来使通信双方在不可信信道中共享密钥的。\n假设甲乙双方需要传递密钥，他们之间可以这么做：\n甲首先选择一个素数p，例如97，底数g是p的一个原根，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是34，然后，甲发送p＝97，g=5，A=34给乙； 乙方收到后，也选择一个随机数b，例如，456，然后计算B = g^b mod p，结果是75，乙再同时计算s = A^b mod p，结果是22； 乙把计算的B=75发给甲，甲计算s ＝ B^a mod p，计算结果与乙算出的结果一样，都是22。 原理解释：\n对于甲的密钥计算过程有： s1 = B^a mod p = (g^b mod p)^a mod p = g^(b*a) mod p\n对于乙的密钥计算过程有： s2 = A^b mod p = (g^a mod p)^b mod p = g^(a*b) mod p\n根据乘法交换律，s1 == s2\n在这个过程中，甲乙双方就达成了共享密钥s的目的。\n第三方只能知道p=97，g=5，A=34，B=75，由于不知道双方选的秘密整数a=123和b=456，因此无法计算出密钥。\nDH算法的安全性建立在离散对数问题上，通俗来讲就是对于一种运算，正向计算的成本和逆向运算的成本极其不对等。\n比如对于上文提到的 A=g^a mod p ，对于甲来说，已知g、a和p，计算A是简单的。而对于第三方来说，已知g、A和p，计算a是困难的。\n如果我们把a看成甲的私钥，A看成甲的公钥，b看成乙的私钥，B看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并\n根据自己的私钥和对方的公钥，生成最终的密钥secretKey，DH算法通过数学定律保证了双方各自计算出的secretKey是相同的。\n同态加密 同态加密（Homomorphic Encryption）是一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果。\n这里的同态和代数上的同态是等价的。\n如果定义一个运算符*，对加密算法 E ，满足：E(x*y)=E(x)*E(y)\n通常的加密方案一般关注的是数据存储安全，也就是说在数据传输或存储过程中，没有密钥的用户，不可能从加密结果中得到有关原始数据的任何信息。只有拥有密钥的用户才能够正 确解密，得到原始的内容。我们注意到，这个过程中用户是不能对加密结果做任何操作的，只能进行存储、传输。对加密结果做任何操作，都将会导致错误的解密，甚至解密失败。\n同态加密方案最有趣的地方在于，其关注的是数据处理安全。同态加密提供了一种对加密数据进行处理的功能。也就是说，其他人可以对加密数据进行处理，但是处理过程不会泄露任何原始内容。同时，拥有密钥的用户对处理过的数据进行解密后，得到的正好是处理后的结果。\n隐写术 通常的加密算法目的是隐藏信息的涵义，而隐写术的目的是隐藏信息的存在。\n比如我们可以在一张图片的二进制末尾追加内容，或是对图片的特定二进制位进行编码，当你正常打开图片时，肉眼无法感知到不同。但是只要你知道编码规则，那么就可以从图片中还原出隐藏的信息。\n完整性 哈希函数 哈希函数（Hash function）又称摘要函数、散列函数，能够将任意长度的输入值转变成固定长度的值输出，该值称为哈希值或散列值，输出值通常为字母与数字组合。\n哈希函数对扰动是敏感的，也就是说原始信息更改哪怕一个字节，哈希计算的结果都会完全不同。\n哈希函数可被用来生成\u0026quot;摘要\u0026quot;来作完整性校验，或者用来存储密码。\n安全的哈希函数通常需要具备以下性质\n原像稳固: 给定一个Hash值 y，很难找到一个 x，使得 y=h(x) 第二原像稳固: 给定一个 x，很难找到另一个值 x’，使得 h(x)=h(x’) 碰撞稳固: 很难找到一对值 x 和 x’ (x≠x’)，使得 h(x)=h(x’) 常见的哈希函数有 MD5，SHA-1，SHA-2等。\n网上说的MD5和SHA-1不再安全，指的都是其碰撞稳固性被打破，而不是第二原像性被打破。\n对于哈希函数，黑客通常会使用彩虹表的方式进行攻击，如MD5解密，也就是通过穷举字符组合，存储了明文密文的映射关系。\n大多数用户在不同的网站或应用中使用相同的密码，当一个网站的数据库被盗取，存储的密码就会被攻击者获取。因此，在存储密码时，不应该直接存储，而应该存储哈希值，并且计算前要加盐避免彩虹表攻击。除此以外，还可以考虑慢哈希函数等。\n可认证性及不可否认性 中间人攻击 上文的加密算法中，虽然已经实现了通信双方可以在不可信信道中共享密钥，来实现加密通信的目的。但是其实还有一个隐藏假设，那就是攻击者只可以监听信道，而不可以篡改信道中的消息。 当攻击者可以篡改信息时，所有的安全性都化为泡影。攻击者只需要在信道中扮演另一方的身份来进行密钥的交换，对于通信双方来说根本无法察觉。\n在这种情况下，我们只能呼叫场外援助(数字证书)了。\n数字签名 数字签名类似现实世界中的签名和盖章，数字签名是一种能防止用户抵赖，伪装，篡改和否认的密码技术。\n对于要签名的信息，签名者先使用哈希函数计算其摘要，然后使用对摘要使用私钥进行加密。\n验签者接收到信息后，使用签名者的公钥进行解密，然后对信息同样计算其摘要。如果两个摘要是相同的，那么就说明该消息没有被篡改。\n目前广泛使用的数字签名算法包括 RSA、ElGamal、DSA、ECDSA等。\n数字证书 最简单的证书包含一个公钥、名称以及证书授权中心(Certificate Authority)的数字签名。一般情况下证书中还包括密钥的有效期，颁发者（证书授权中心）的名称，该证书的序列号等信息，证书的结构遵循X.509 v3版本的规范。\n点击一下浏览器网址中的小锁，就可以看到网站的证书了。 在TLS握手过程中，服务端会发送自己的数字证书，可以看到证书的结构是分层级的，为 GTS Root R1 -\u0026gt; GTS CA 1C3 -\u0026gt; www.google.com\n对客户端来说，网页证书并不可靠，但是它被二级CA机构签发了，那么二级CA可不可靠呢，也不可靠，但是二级CA的证书被根CA机构签发了。\n由于我们的电脑中都预装了根CA证书，我们可以通过根CA公钥验证数字签名，因此二级证书也是可靠的；由此，网站也是可靠的。\n数字证书的假设是：根CA及其证书是可靠有效的。\n可见，数字证书是一种基于数字签名的信任传导机制。\n总结 ref https://halfrost.com/cryptography_overview 维基百科\n","permalink":"https://Kazekumo.github.io/posts/thinking-crypto/","summary":"密码学的目的在于保护信息的安全性。\n密码学通常关注以下性质的研究：\n机密性：不将信息泄露给第三方 完整性：信息传递时，信息不被篡改，或在篡改后能够被迅速发现 可认证性：消息来源和消息本身是可认证的，而非伪造的 不可否认性：用户无法在事后否认曾经进行信息的生成，签发，接收行为 当然，对于开发人员来说，更关注加密工具的使用，因此下文介绍一些密码学常见原语，让阅读人员能有一个感性的认知。\n机密性 对称加密 对称加密(Symmetric Encryption)指的是加密和解密都使用同一个密钥。\n消息发送者，发送信息传递前先进行加密。接受者收到消息后先进行解密。\n对称加密建立在这样一个假设下：\n在消息传递前，通信双方已通过其他可靠方式共享了密钥(secretKey)\n对称加密不仅简单，而且加密效率高。但是问题在于通信双方如何共享一个密钥，而不泄露给第三方。\n常见的对称加密算法有 DES, AES 等。\n非对称加密 非对称加密(Asymmetric Cryptography)，如它的名字一样，和对称加密相比，它最显著的区别在于加解密使用的不是同一个密钥。\n非对称加密中，密钥成对出现，有公钥(public key)和私钥(private key)的区别。并且通信双方并不共享同一密钥，而是使用对方的公钥进行加密，自己的私钥进行解密。\n以甲乙双方为例，通信过程如下:\n甲使用乙的公钥对消息1进行加密，并发送给乙； 乙使用自己的私钥进行解密，获得消息明文； 乙使用甲的公钥对消息2进行加密，并发送给甲； 甲使用自己的私钥进行解密，获得消息明文。 常见的非对称加密算法有RSA、Elgamal、ECC算法等。\n非对称加密的假设更加复杂，通信双方需要提前共享对方的公钥才可以安全通信，并且非对称加密的性能比对称加密要差得多。\n但是算法的提出一定尤其背后的意义，这里介绍一下DH算法。\nDiffie-Hellman算法 上面提到，对称加密假设通信双方已经共享同一个密钥。DH算法便是用来使通信双方在不可信信道中共享密钥的。\n假设甲乙双方需要传递密钥，他们之间可以这么做：\n甲首先选择一个素数p，例如97，底数g是p的一个原根，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是34，然后，甲发送p＝97，g=5，A=34给乙； 乙方收到后，也选择一个随机数b，例如，456，然后计算B = g^b mod p，结果是75，乙再同时计算s = A^b mod p，结果是22； 乙把计算的B=75发给甲，甲计算s ＝ B^a mod p，计算结果与乙算出的结果一样，都是22。 原理解释：\n对于甲的密钥计算过程有： s1 = B^a mod p = (g^b mod p)^a mod p = g^(b*a) mod p","title":"密码学漫谈"},{"content":"为什么有JVM 在学习JVM之前，大家可以先思考一个问题，为什么我们需要JVM\n以上图为例，cpp开发的软件具备一个明显劣势，那就是他无法满足跨平台的需求(一次编写，处处编译)\n计算机领域有一句名言：\n计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.\nJVM便是通过增加中间层实现了 一次编译，处处运行\nJVM能做什么 平台无关性 语言无关性 JVM运行机制 垃圾回收算法 除了上面的跨平台性，Java 和 cpp相比，还有一个显著的区别，那就是内存动态分配和垃圾回收。\n对于GC，我们需要考虑2个问题：\n哪些内存需要回收? 如何回收? 程序计数器、虚拟机栈、本地方法栈 3 个区域是 Thread Local 的，随线程而生，随线程而灭，自然也不用过多关心如何回收的问题。\n然而 Heap 和方法区有显著的不确定性，这部分内存更是实际中用得最多的内存，也因此诞生了许多分配与回收算法。\n引用计数 引用记数（Reference Counting）是最简单的一种收集方法，许多编程语言使用该方法管理内存（Objective-C、Swift 等）\n它的缺点和优势都很明显。它的判定效率高，占用低。然而仍然需要程序员在编码时额外配合，必须手动将对象置空。\n除此之外，它无法解决循环引用问题。\n可达性分析 当一块内存永远不可能再被访问到时，他就应该回收\n如图所示，该算法的主要思路是把一系列被称作「GC Roots」的根对象作为起始节点，从这些节点开始往下搜索，搜索过的路径称作「引用链」（Reference Chain）。如果某个对象和 GC Roots 间没有引用链连接。就说明该对象不可达，也就不可能再被使用。\n在 JVM 中，可作为 GC Roots 的对象有以下几种：\nVM Stack 中引用的对象，如方法参数、局部变量、临时变量等。 在方法区内的静态属性对象 在方法去内常量引用的对象，如字符串常量池（String Table）中的引用 本地方法栈中 JNI 引用的对象 JVM 内部引用，如基本数据类型对应的 Class 对象，一些长驻的异常对象（NPE OOM 等），以及类加载器。 所有被同步锁（synchronized 关键字）持有的对象 JMXBean、JVMTI 中的回调、本地代码缓存等 垃圾回收算法 分代收集（Generational Collection）理论是最广泛应用的垃圾收集理论，建立在两个分代假说之上：\n弱分代假说（Weak Generational Hypothesis）：大多数对象朝生夕灭 强分代假说（Strong Generational Hypothesis）：熬过越多次 GC 的对象，越难以消亡 因此，很容易想到将内存划分为多个区域，针对不同区域的特点，优化收集算法。很多 JVM GC 就是这么做的。\n譬如，可以将 Heap 分为新生代和老年代。很多对象在新生代中就会死去，而熬过 GC 的对象，就可以逐步放到老年代中管理。所以，JVM 可以每次只回收其中某一个或者某些部分的区域。从而还出现了「Minor GC」「Major GC」「Full GC」这样的划分。\n然而这样的模型仍然是不完备的。比如，现在要进行一次 Minor GC（只清除新生代），但新生代中的对象却可能被老年代所引用。为了找出新生代的存活对象，却不得不在 GC Roots 之外，额外搜讯老年代中所有对象，来确保可达性分析的正确性，反之亦然。为了避免造成极大的性能损失，还需要第三条假说：\n跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用对比同代引用，少之又少 基于 1、2 两条假说，推出这条很自然：两个存在引用关系的对象，倾向于同生同死。比如，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，所以新生代也会逐渐晋升到老年代中，跨代引用也就被消除了。\n因此 Minor GC 时，就不必扫描整个老年代，而是只扫描相关的区域。这样就可以极大减少运行时开销。\n后续会使用的 GC Term：\nPartial GC：不完整收集整个 Heap 的 GC\nMinor GC / Young GC：只收集新生代\nMajor GC / Old GC：本文中指只收集老年代，然而这个说法常常和 Full GC 混淆，需要根据上下文判断。\nMixed GC：混合收集新生代和老年代。\nFull GC：收集整个 Heap 和方法区。\n清除算法 标记-清除 最基础的 GC 算法是「标记-清除」（Mark-Sweep）。分为「标记」、「清除」两个阶段。首先标记出所有需要回收的对象，然后统一回收。标记过程之前已经讲过了。\n如图：\n他的缺点很明显：\n效率低，JVM 需要大量的标记和清除操作，随着对象数量增长，速度会极速下降 内存空间碎片化，会产生大量不连续的内存空间，导致内存利用率不高 标记-复制 标记-复制（mark-copying）算法将内存分为两块。若一块内存用毕，就对这块区域进行一次垃圾收集，将还存活的对象复制到另一块区域上。每次只使用一块，并将另一块内存保留。\n若回收时多数对象都是存活的，这将会产生大量复制开销。但如果多数对象都是死亡的，那么复制开销就很低。同时，也毋须考虑碎片化问题，因为会直接清除一个区块的内存。当然，缺点也显而易见，这浪费了一半的内存。\n回想一下分代假设：1. 大多数对象朝生夕灭；2. 熬过越多次 GC 的对象，越难以消亡。\n因此对于新生代中的对象，就非常适合 Mark-Copy 算法。\n在 1989 年，Andrew Appel 就提出了将 Mark-Copy 优化后的策略。将新生代分为较大的一块 Eden 和两块 Survivor。分配时使用 Eden 和一块 Survivor。GC 时，将 Eden 和其中一块 Survivor 内存区域中的存活对象，复制到另一块 Survivor 空间上。HotSpot VM 默认的比例为 Eden:Survivor=8:1Eden:Survivor=8:1 。也就是说，只有 10%10% 的内存会被浪费（因为有两块 Survivor，最终比例是 8:1:18:1:1）。\n此外，还需要考虑到大量创建对象的极端情况。因此就有分配担保（Handle Promotion）机制。可以直接将新对象放入老年代，避免反复收集。具体细节，会在以后详解。\n标记-整理 标记-复制算法固然能在新生代大放光彩，然而若在老年代，对象存活率较高，较多的复制操作会让性能骤降。\n针对老年代特征，可以使用标记-整理（Mark-Compact）算法。其机制就是在标记-清楚基础之上，增加一个移动内存的步骤。\n然而，移动存活对象的代价是很高的，尤其是老年代这种大区块。移动存活对象并更新引用是一项沉重、耗时的操作，必须停止整个程序进行 GC，i.e. stop the world. 极大影响程序的响应速度。\n如果你玩过 Minecraft Java 版，那么你很有可能已经经历过其中的酸爽了。程序占用的内存到达了 JVM 设置的上限。反复地经历新对象创建和 Full GC 循环，反复停止整个程序[^1]。（这种情况也被某些人叫做「内存抖动」）体现在游戏中，就是每隔几秒画面静止一下，体验非常差。\n当然，这里是指多数 GC 会停止整个程序。较新的一些 GC，如 ZGC，可以通过其他手段避免暂停全局。\n然而，若不 Compact，空间碎片化问题同样恼人。可以使用分区等方式将物理上不连续的内存，化为逻辑上连续的。（硬盘正是这么做的）但这会降低程序的吞吐量。\n垃圾收集器 分代收集算法概念：根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为新生代、老年代和永久代，并根据各个年代的特点分别采用不同的GC算法\n新生代——负责算法\n老年代——标记整理算法\n特点\n适用算法\n新生代\n对象生命周期短，标记阶段会标记大量已死亡对象\n复制算法\n老年代\n生命周期长的对象、大对象，可回收数量少\n标记整理算法\n永久代\n存储Class类、常量、方法描述等\n回收废弃的常量、无用的类\n分区收集算法概念：将整个堆空间划分为连续的大小不同的小区域，每个小区域单独进行内存使用和垃圾回收，这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。根据系统可接受的停顿时间，每次都快速回收若干个小区域，从而减少一次GC所产生的的停顿时间，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。\nSerial收集器（年轻代） 最简单高效粗暴的单线程年轻代垃圾回收器，但是STW/延迟时间最长。\n但是并不是一无是处，适合用在一些小内存的客户端程序，比如几百M的内存只要100毫秒以内就可以回收完，对用户没什么影响。\nParNew收集器（年轻代） 多线程并行版的Serial年轻代垃圾回收器。\nSerial Old收集器（老年代） 单线程的老年代垃圾回收器。\nParallel Old收集器（老年代） 多线程的并行老年代回收器。\nParallel Scanvenge收集器（年轻代） 也是多线程并发的年轻代回收器，但是这款垃圾回收器不是考虑如何缩短STW，而是吞吐量，即如何减少垃圾回收器总的回收时间，保障用户执行时间。所以可以应用的场景是跑批的应用，不用太在乎单次STW卡顿时间，只要能够尽可能得利用CPU资源跑完程序就好。\n用这个垃圾回收器有3个关键参数要注意：\n吞吐量（-XX：GCTimeRatio）：设置为99%，意味着100分钟里，只有1分钟在垃圾回收，99分钟都在跑用户代码。 单次最大垃圾回收时间（-XX：MaxGCPauseMillis）：效果与吞吐量相反的参数是。这两个参数是相互矛盾的，所以二选一，要么吞吐量优先，要么限制单次垃圾回收时间优先。 问题：那么是不是可以把单次最大垃圾回收时间设置得非常短，那岂不是就不会有卡顿？\n答：垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的：系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。\n内存自适应（-XX：+UseAdaptiveSizePolicy）：只要设置最大堆大小（-Xmx）就可以，不用关注年轻代大小、Eden和Survivor比例等。 所以这个垃圾回收器的一般用法是：设置最大堆大小（-Xmx），内存选择自适应（-XX：+UseAdaptiveSizePolicy），不用管年轻代大小、Eden和Survivor比例，然后告诉虚拟机吞吐量目标（-XX：GCTimeRatio）或者少延迟/卡顿优先（-XX：MaxGCPauseMillis）。\nCMS（ConcurrentMarkSweep）收集器（老年代） 比并发的老年代收集器Parallel Old又在进步一些，追求垃圾回收期间与用户程序并发、且低延迟，适合用在面向互联网用户的服务器应用。垃圾收集算法是标记-清除，清除不会造成STW，所以优化点是标记，用到前面讲到的办法将标记过程拆细，分为初始标记（卡顿）、并发标记（无需卡顿）、二次标记（卡顿），初始标记、二次标记虽然卡顿但时间都很短。步骤分为四步：\n1）初始标记（CMSinitialmark）：会卡顿\n2）并发标记（CMSconcurrentmark）：\n3）二次/重新标记（CMSremark）：会卡顿\n4）并发清除（CMSconcurrentsweep）\n有3个关键问题：\n1）虽然可以并发进行标记、清理减少卡顿，但是多线程并行会消耗机器资源导致用户程序变慢，吞吐量降低。\n使用这款垃圾回收器要注意CPU核数的选择：CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。**但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。**如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。\n2）并发标记、并发清理过程中用户程序又分配新对象怎么办？\n跟其他垃圾回收器不一样，不能等到老年代满了才进行垃圾回收了，因为回收过程中与用户线程并发，用户线程会产生新的对象，因此有一个参数（-XX：CMSInitiatingOccu-pancyFraction）控制老年代占用内存比例到达多少时触发垃圾回收，默认值是92%。如果并发期间分配对象还是失败，就会触发一次兜底的Serial Old。\n3）标记-清除算法内存碎片问题\n如果多次标记-清除，内存碎片太多无法找到足够大的连续空间分配对象，就会触发一次带内存碎片整理的Full GC（- XX：+ UseCMS-CompactAtFullCollection参数控制Full GC前是否需要内存整理，默认开启。\n一个收集器就可以搞定整个内存的垃圾回收，不需要配置两个年轻代和老年代的垃圾回收器了，因为内存布局跟原来完全不一样了，年轻代和老年代粒度变小了，如下图，这种方式叫基于Region的内存布局，每个Region大小相等。\n这么设计有什么好处？\n和垃圾回收器G1（Garbage First）的命名相关，追求的目标是固定一个延迟时间，不再区分回收年轻代还是老年代，而是回收价值最大（能够回收最多内存的的区域），Garbage First可以叫回收效益排名第一的垃圾回收器。\n关键参数- XX：MaxGCPauseMillis，默认值是200ms，核心的实现思路是建议停顿预测模型，即记录回收每个Region可能需要耗费的时间。\n每次回收的过程跟CMS差不多，不过用的是标记-复制。\n1）初始标记(Initial Marking)：会卡顿\n2）并发标记（Concurrent Marking）\n3）最终标记（Final Marking）：会卡顿\n4）筛选回收（Live Data Counting and Evacuation)：回收价值最高的Region，用复制算法，会卡顿\n启示和展望 架构的本质是领域划分和依赖分析\n依赖的原则：1.显示依赖 2.每层只能与位于其下方的层发生耦合\nJVM设计之时的市场环境和现在已经发生了天翻地覆的变化，不由让我们思考这样一个问题：我们是否还需要JVM? 我们是否真的还需要平台无关性？\n将在的Java JVM 和 浏览器的v8引擎 进行比较，可以很明显的发现，我们不再需要客户端了，也不再需要平台无关性了，服务端的一切我们都是可控的。面对云原生的浪潮，Java将做出什么样的改变，这个问题就留给读者思考了。\nref 深入理解Java虚拟机 https://book.douban.com/subject/34907497/\njvm参数生成及工具指引 https://render.alipay.com/p/s/jvm-generate/JvmGenerate\njvm在线诊断 https://arthas.aliyun.com/\ngc日志在线分析 https://gceasy.io/\nhttps://www.yuque.com/belber/archive/bhgel2?#QWTJx\n","permalink":"https://Kazekumo.github.io/posts/thinking-jvm/","summary":"为什么有JVM 在学习JVM之前，大家可以先思考一个问题，为什么我们需要JVM\n以上图为例，cpp开发的软件具备一个明显劣势，那就是他无法满足跨平台的需求(一次编写，处处编译)\n计算机领域有一句名言：\n计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.\nJVM便是通过增加中间层实现了 一次编译，处处运行\nJVM能做什么 平台无关性 语言无关性 JVM运行机制 垃圾回收算法 除了上面的跨平台性，Java 和 cpp相比，还有一个显著的区别，那就是内存动态分配和垃圾回收。\n对于GC，我们需要考虑2个问题：\n哪些内存需要回收? 如何回收? 程序计数器、虚拟机栈、本地方法栈 3 个区域是 Thread Local 的，随线程而生，随线程而灭，自然也不用过多关心如何回收的问题。\n然而 Heap 和方法区有显著的不确定性，这部分内存更是实际中用得最多的内存，也因此诞生了许多分配与回收算法。\n引用计数 引用记数（Reference Counting）是最简单的一种收集方法，许多编程语言使用该方法管理内存（Objective-C、Swift 等）\n它的缺点和优势都很明显。它的判定效率高，占用低。然而仍然需要程序员在编码时额外配合，必须手动将对象置空。\n除此之外，它无法解决循环引用问题。\n可达性分析 当一块内存永远不可能再被访问到时，他就应该回收\n如图所示，该算法的主要思路是把一系列被称作「GC Roots」的根对象作为起始节点，从这些节点开始往下搜索，搜索过的路径称作「引用链」（Reference Chain）。如果某个对象和 GC Roots 间没有引用链连接。就说明该对象不可达，也就不可能再被使用。\n在 JVM 中，可作为 GC Roots 的对象有以下几种：\nVM Stack 中引用的对象，如方法参数、局部变量、临时变量等。 在方法区内的静态属性对象 在方法去内常量引用的对象，如字符串常量池（String Table）中的引用 本地方法栈中 JNI 引用的对象 JVM 内部引用，如基本数据类型对应的 Class 对象，一些长驻的异常对象（NPE OOM 等），以及类加载器。 所有被同步锁（synchronized 关键字）持有的对象 JMXBean、JVMTI 中的回调、本地代码缓存等 垃圾回收算法 分代收集（Generational Collection）理论是最广泛应用的垃圾收集理论，建立在两个分代假说之上：\n弱分代假说（Weak Generational Hypothesis）：大多数对象朝生夕灭 强分代假说（Strong Generational Hypothesis）：熬过越多次 GC 的对象，越难以消亡 因此，很容易想到将内存划分为多个区域，针对不同区域的特点，优化收集算法。很多 JVM GC 就是这么做的。","title":"JVM笔记"},{"content":"开发中发现许多对象都依赖了css的基类对象BaseEntity 偶然点开发现里面的写法不太容易理解，因此分析记录一下\n点开对象可以发现，有两个属性是比较特别的，也就是 propMap 和 visitor 本文的目的也主要是分析这两个对象的用途。\n先直接看这两个对象在哪用了，翻阅源码可以发现，两个属性的主要使用入口都在toString中。 最终这个函数是调用了toString0 或者 hexString 初见这一坨，我也百思不得其解，先不管，继续看看toString0 分析代码可知，toString0这个方法才是对象转字符串的主要实现，通过getProps获取对象的属性列表，然后在下面进行属性的拼接 看看getProps，可以发现propMap的用途是存储该类的所有属性名称。 如果该对象的属性未初始化，则通过反射获取。 需要注意的是，这里使用了 double check lock，避免重入。 当第二次进入时，就可以复用属性，不用再反射获取了。 到了此处，propMap 的用途基本就解答了。\n那么为啥要有 visotor 呢？我们再回过头来看toString方法 在toString方法中，visitor 的逻辑主要如下\n如果 visitor为空，重新初始化 visitor 如果 visitor.get() 为空： 1. 设置 visitor 为当前对象 2. 调用 toString0 3. 设置 visitor 为 null 如果 visitor 的值不为空，返回 HexString 这里的目的不太好理解。首先对于步骤1，我们可以先忽略，因为实际不影响流程。 控制流程的主要是步骤2和步骤3。 首先可以观察到，步骤2的进入条件是 visitor 为空，步骤3的进入条件为 visitor 不为空。也就是说，步骤2和步骤3这两步操作是互斥的。 在步骤2.1中，设置了 visitor 为当前对象，然后在2.3中又重置了回去。那么也就是说同一个线程，他不能重入步骤2。\n这里比较有迷惑性，因为threadLocal是线程独立的，搞这么复杂干嘛呢，同一个线程还能重入这个方法不成？ 读者可以先思考一下，表情包下面给出答案。\n同一个线程还能重入这个方法不成？确实是可能的。 答案就是当对象发生了循环引用，这时调用toString方法，序列化子对象时，由于循环引用，就会再次进入父对象的toString方法，不断套娃，最终导致栈溢出。 所以此处使用visitor进行流程控制的目的就是为了打破这个循环调用链。\n实际上，许多框架都支持了循环引用，不过方式上可能有些许差异，比如 FastJson 使用 $ref 占位符避免序列化子对象，Spring 使用了多级缓存的方式等等，这里就不赘述了。\n框架开发人员总是考虑到各种场景进行了兼容，不过我认为大部分循环引用，其实并不值得解决，因为其代表是层级结构本身的不合理。\n","permalink":"https://Kazekumo.github.io/posts/baseentity-analysis/","summary":"开发中发现许多对象都依赖了css的基类对象BaseEntity 偶然点开发现里面的写法不太容易理解，因此分析记录一下\n点开对象可以发现，有两个属性是比较特别的，也就是 propMap 和 visitor 本文的目的也主要是分析这两个对象的用途。\n先直接看这两个对象在哪用了，翻阅源码可以发现，两个属性的主要使用入口都在toString中。 最终这个函数是调用了toString0 或者 hexString 初见这一坨，我也百思不得其解，先不管，继续看看toString0 分析代码可知，toString0这个方法才是对象转字符串的主要实现，通过getProps获取对象的属性列表，然后在下面进行属性的拼接 看看getProps，可以发现propMap的用途是存储该类的所有属性名称。 如果该对象的属性未初始化，则通过反射获取。 需要注意的是，这里使用了 double check lock，避免重入。 当第二次进入时，就可以复用属性，不用再反射获取了。 到了此处，propMap 的用途基本就解答了。\n那么为啥要有 visotor 呢？我们再回过头来看toString方法 在toString方法中，visitor 的逻辑主要如下\n如果 visitor为空，重新初始化 visitor 如果 visitor.get() 为空： 1. 设置 visitor 为当前对象 2. 调用 toString0 3. 设置 visitor 为 null 如果 visitor 的值不为空，返回 HexString 这里的目的不太好理解。首先对于步骤1，我们可以先忽略，因为实际不影响流程。 控制流程的主要是步骤2和步骤3。 首先可以观察到，步骤2的进入条件是 visitor 为空，步骤3的进入条件为 visitor 不为空。也就是说，步骤2和步骤3这两步操作是互斥的。 在步骤2.1中，设置了 visitor 为当前对象，然后在2.3中又重置了回去。那么也就是说同一个线程，他不能重入步骤2。\n这里比较有迷惑性，因为threadLocal是线程独立的，搞这么复杂干嘛呢，同一个线程还能重入这个方法不成？ 读者可以先思考一下，表情包下面给出答案。\n同一个线程还能重入这个方法不成？确实是可能的。 答案就是当对象发生了循环引用，这时调用toString方法，序列化子对象时，由于循环引用，就会再次进入父对象的toString方法，不断套娃，最终导致栈溢出。 所以此处使用visitor进行流程控制的目的就是为了打破这个循环调用链。\n实际上，许多框架都支持了循环引用，不过方式上可能有些许差异，比如 FastJson 使用 $ref 占位符避免序列化子对象，Spring 使用了多级缓存的方式等等，这里就不赘述了。","title":"某基类的源码分析"}]