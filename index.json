[{"content":"密码学的目的在于保护信息的安全性。\n密码学通常关注以下性质的研究：\n机密性：不将信息泄露给第三方 完整性：信息传递时，信息不被篡改，或在篡改后能够被迅速发现 可认证性：消息来源和消息本身是可认证的，而非伪造的 不可否认性：用户无法在事后否认曾经进行信息的生成，签发，接收行为 当然，对于开发人员来说，更关注加密工具的使用，因此下文介绍一些密码学常见原语，让阅读人员能有一个感性的认知。\n机密性 对称加密 对称加密(Symmetric Encryption)指的是加密和解密都使用同一个密钥。\n消息发送者，发送信息传递前先进行加密。接受者收到消息后先进行解密。\n对称加密建立在这样一个假设下：\n在消息传递前，通信双方已通过其他可靠方式共享了密钥(secretKey)\n对称加密不仅简单，而且加密效率高。但是问题在于通信双方如何共享一个密钥，而不泄露给第三方。\n常见的对称加密算法有 DES, AES 等。\n非对称加密 非对称加密(Asymmetric Cryptography)，如它的名字一样，和对称加密相比，它最显著的区别在于加解密使用的不是同一个密钥。\n非对称加密中，密钥成对出现，有公钥(public key)和私钥(private key)的区别。并且通信双方并不共享同一密钥，而是使用对方的公钥进行加密，自己的私钥进行解密。\n以甲乙双方为例，通信过程如下:\n甲使用乙的公钥对消息1进行加密，并发送给乙； 乙使用自己的私钥进行解密，获得消息明文； 乙使用甲的公钥对消息2进行加密，并发送给甲； 甲使用自己的私钥进行解密，获得消息明文。 常见的非对称加密算法有RSA、Elgamal、ECC算法等。\n非对称加密的假设更加复杂，通信双方需要提前共享对方的公钥才可以安全通信，并且非对称加密的性能比对称加密要差得多。\n但是算法的提出一定尤其背后的意义，这里介绍一下DH算法。\nDiffie-Hellman算法 上面提到，对称加密假设通信双方已经共享同一个密钥。DH算法便是用来使通信双方在不可信信道中共享密钥的。\n假设甲乙双方需要传递密钥，他们之间可以这么做：\n甲首先选择一个素数p，例如97，底数g是p的一个原根，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是34，然后，甲发送p＝97，g=5，A=34给乙； 乙方收到后，也选择一个随机数b，例如，456，然后计算B = g^b mod p，结果是75，乙再同时计算s = A^b mod p，结果是22； 乙把计算的B=75发给甲，甲计算s ＝ B^a mod p，计算结果与乙算出的结果一样，都是22。 原理解释：\n对于甲的密钥计算过程有： s1 = B^a mod p = (g^b mod p)^a mod p = g^(b*a) mod p\n对于乙的密钥计算过程有： s2 = A^b mod p = (g^a mod p)^b mod p = g^(a*b) mod p\n根据乘法交换律，s1 == s2\n在这个过程中，甲乙双方就达成了共享密钥s的目的。\n第三方只能知道p=97，g=5，A=34，B=75，由于不知道双方选的秘密整数a=123和b=456，因此无法计算出密钥。\nDH算法的安全性建立在离散对数问题上，通俗来讲就是对于一种运算，正向计算的成本和逆向运算的成本极其不对等。\n比如对于上文提到的 A=g^a mod p ，对于甲来说，已知g、a和p，计算A是简单的。而对于第三方来说，已知g、A和p，计算a是困难的。\n如果我们把a看成甲的私钥，A看成甲的公钥，b看成乙的私钥，B看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并\n根据自己的私钥和对方的公钥，生成最终的密钥secretKey，DH算法通过数学定律保证了双方各自计算出的secretKey是相同的。\n同态加密 同态加密（Homomorphic Encryption）是一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果。\n这里的同态和代数上的同态是等价的。\n如果定义一个运算符*，对加密算法 E ，满足：E(x*y)=E(x)*E(y)\n通常的加密方案一般关注的是数据存储安全，也就是说在数据传输或存储过程中，没有密钥的用户，不可能从加密结果中得到有关原始数据的任何信息。只有拥有密钥的用户才能够正 确解密，得到原始的内容。我们注意到，这个过程中用户是不能对加密结果做任何操作的，只能进行存储、传输。对加密结果做任何操作，都将会导致错误的解密，甚至解密失败。\n同态加密方案最有趣的地方在于，其关注的是数据处理安全。同态加密提供了一种对加密数据进行处理的功能。也就是说，其他人可以对加密数据进行处理，但是处理过程不会泄露任何原始内容。同时，拥有密钥的用户对处理过的数据进行解密后，得到的正好是处理后的结果。\n隐写术 通常的加密算法目的是隐藏信息的涵义，而隐写术的目的是隐藏信息的存在。\n比如我们可以在一张图片的二进制末尾追加内容，或是对图片的特定二进制位进行编码，当你正常打开图片时，肉眼无法感知到不同。但是只要你知道编码规则，那么就可以从图片中还原出隐藏的信息。\n完整性 哈希函数 哈希函数（Hash function）又称摘要函数、散列函数，能够将任意长度的输入值转变成固定长度的值输出，该值称为哈希值或散列值，输出值通常为字母与数字组合。\n哈希函数对扰动是敏感的，也就是说原始信息更改哪怕一个字节，哈希计算的结果都会完全不同。\n哈希函数可被用来生成\u0026quot;摘要\u0026quot;来作完整性校验，或者用来存储密码。\n安全的哈希函数通常需要具备以下性质\n原像稳固: 给定一个Hash值 y，很难找到一个 x，使得 y=h(x) 第二原像稳固: 给定一个 x，很难找到另一个值 x’，使得 h(x)=h(x’) 碰撞稳固: 很难找到一对值 x 和 x’ (x≠x’)，使得 h(x)=h(x’) 常见的哈希函数有 MD5，SHA-1，SHA-2等。\n网上说的MD5和SHA-1不再安全，指的都是其碰撞稳固性被打破，而不是第二原像性被打破。\n对于哈希函数，黑客通常会使用彩虹表的方式进行攻击，如MD5解密，也就是通过穷举字符组合，存储了明文密文的映射关系。\n大多数用户在不同的网站或应用中使用相同的密码，当一个网站的数据库被盗取，存储的密码就会被攻击者获取。因此，在存储密码时，不应该直接存储，而应该存储哈希值，并且计算前要加盐避免彩虹表攻击。除此以外，还可以考虑慢哈希函数等。\n可认证性及不可否认性 中间人攻击 上文的加密算法中，虽然已经实现了通信双方可以在不可信信道中共享密钥，来实现加密通信的目的。但是其实还有一个隐藏假设，那就是攻击者只可以监听信道，而不可以篡改信道中的消息。 当攻击者可以篡改信息时，所有的安全性都化为泡影。攻击者只需要在信道中扮演另一方的身份来进行密钥的交换，对于通信双方来说根本无法察觉。\n在这种情况下，我们只能呼叫场外援助(数字证书)了。\n数字签名 数字签名类似现实世界中的签名和盖章，数字签名是一种能防止用户抵赖，伪装，篡改和否认的密码技术。\n对于要签名的信息，签名者先使用哈希函数计算其摘要，然后使用对摘要使用私钥进行加密。\n验签者接收到信息后，使用签名者的公钥进行解密，然后对信息同样计算其摘要。如果两个摘要是相同的，那么就说明该消息没有被篡改。\n目前广泛使用的数字签名算法包括 RSA、ElGamal、DSA、ECDSA等。\n数字证书 最简单的证书包含一个公钥、名称以及证书授权中心(Certificate Authority)的数字签名。一般情况下证书中还包括密钥的有效期，颁发者（证书授权中心）的名称，该证书的序列号等信息，证书的结构遵循X.509 v3版本的规范。\n点击一下浏览器网址中的小锁，就可以看到网站的证书了。 在TLS握手过程中，服务端会发送自己的数字证书，可以看到证书的结构是分层级的，为 GTS Root R1 -\u0026gt; GTS CA 1C3 -\u0026gt; www.google.com\n对客户端来说，网页证书并不可靠，但是它被二级CA机构签发了，那么二级CA可不可靠呢，也不可靠，但是二级CA的证书被根CA机构签发了。\n由于我们的电脑中都预装了根CA证书，我们可以通过根CA公钥验证数字签名，因此二级证书也是可靠的；由此，网站也是可靠的。\n数字证书的假设是：根CA及其证书是可靠有效的。\n可见，数字证书是一种基于数字签名的信任传导机制。\n总结 ref https://halfrost.com/cryptography_overview 维基百科\n","permalink":"https://Kazekumo.github.io/posts/thinking-crypto/","summary":"密码学的目的在于保护信息的安全性。\n密码学通常关注以下性质的研究：\n机密性：不将信息泄露给第三方 完整性：信息传递时，信息不被篡改，或在篡改后能够被迅速发现 可认证性：消息来源和消息本身是可认证的，而非伪造的 不可否认性：用户无法在事后否认曾经进行信息的生成，签发，接收行为 当然，对于开发人员来说，更关注加密工具的使用，因此下文介绍一些密码学常见原语，让阅读人员能有一个感性的认知。\n机密性 对称加密 对称加密(Symmetric Encryption)指的是加密和解密都使用同一个密钥。\n消息发送者，发送信息传递前先进行加密。接受者收到消息后先进行解密。\n对称加密建立在这样一个假设下：\n在消息传递前，通信双方已通过其他可靠方式共享了密钥(secretKey)\n对称加密不仅简单，而且加密效率高。但是问题在于通信双方如何共享一个密钥，而不泄露给第三方。\n常见的对称加密算法有 DES, AES 等。\n非对称加密 非对称加密(Asymmetric Cryptography)，如它的名字一样，和对称加密相比，它最显著的区别在于加解密使用的不是同一个密钥。\n非对称加密中，密钥成对出现，有公钥(public key)和私钥(private key)的区别。并且通信双方并不共享同一密钥，而是使用对方的公钥进行加密，自己的私钥进行解密。\n以甲乙双方为例，通信过程如下:\n甲使用乙的公钥对消息1进行加密，并发送给乙； 乙使用自己的私钥进行解密，获得消息明文； 乙使用甲的公钥对消息2进行加密，并发送给甲； 甲使用自己的私钥进行解密，获得消息明文。 常见的非对称加密算法有RSA、Elgamal、ECC算法等。\n非对称加密的假设更加复杂，通信双方需要提前共享对方的公钥才可以安全通信，并且非对称加密的性能比对称加密要差得多。\n但是算法的提出一定尤其背后的意义，这里介绍一下DH算法。\nDiffie-Hellman算法 上面提到，对称加密假设通信双方已经共享同一个密钥。DH算法便是用来使通信双方在不可信信道中共享密钥的。\n假设甲乙双方需要传递密钥，他们之间可以这么做：\n甲首先选择一个素数p，例如97，底数g是p的一个原根，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是34，然后，甲发送p＝97，g=5，A=34给乙； 乙方收到后，也选择一个随机数b，例如，456，然后计算B = g^b mod p，结果是75，乙再同时计算s = A^b mod p，结果是22； 乙把计算的B=75发给甲，甲计算s ＝ B^a mod p，计算结果与乙算出的结果一样，都是22。 原理解释：\n对于甲的密钥计算过程有： s1 = B^a mod p = (g^b mod p)^a mod p = g^(b*a) mod p","title":"密码学漫谈"},{"content":"为什么有JVM 在学习JVM(Java Virtual Machine )之前，大家可以先思考一个问题，为什么我们需要JVM\n以上图为例，cpp开发的软件具备一个明显劣势，那就是他无法满足跨平台的需求(一次编写，处处编译)\n计算机领域有一句名言：\n计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.\nJVM便是通过增加中间层实现了一次编译，处处运行\nJVM能做什么 平台无关性: 通过class文件将程序和机器环境进行解耦，运行时再翻译成机器码 语言无关性: JVM不与Java等任何程序语言进行绑定，只要是符合标准的class文件都可以运行在JVM上 JVM运行机制 垃圾回收 除了上面的跨平台性，Java 和 cpp相比，还有一个显著的区别，那就是内存动态分配和垃圾回收。\n对于GC(Garbage Collection)，我们需要考虑2个问题：\n哪些内存需要回收? 如何回收? 程序计数器、虚拟机栈、本地方法栈 3 个区域是 Thread Local 的，随线程而生，随线程而灭，自然也不用过多关心如何回收的问题。\n然而 Heap 和方法区有显著的不确定性，这部分内存更是实际中用得最多的内存，也因此诞生了许多分配与回收算法。\n引用计数 引用记数（Reference Counting）是最简单的一种收集方法，许多编程语言使用该方法管理内存（Objective-C、Swift 等）\n它的缺点和优势都很明显。它的判定效率高，占用低。然而仍然需要程序员在编码时额外配合，必须手动将对象置空。\n除此之外，它无法解决循环引用问题。\n可达性分析 当一块内存永远不可能再被访问到时，他就应该被回收。\n如图所示，该算法的主要思路是把一系列被称作「GC Roots」的根对象作为起始节点，从这些节点开始往下搜索，搜索过的路径称作「引用链」（Reference Chain）。如果某个对象和 GC Roots 间没有引用链连接。就说明该对象不可达，也就不可能再被使用。\n在 JVM 中，可作为 GC Roots 的对象有以下几种：\nVM Stack 中引用的对象，如方法参数、局部变量、临时变量等。 在方法区内的静态属性对象 在方法去内常量引用的对象，如字符串常量池（String Table）中的引用 本地方法栈中 JNI 引用的对象 JVM 内部引用，如基本数据类型对应的 Class 对象，一些长驻的异常对象（NPE OOM 等），以及类加载器。 所有被同步锁（synchronized 关键字）持有的对象 JMXBean、JVMTI 中的回调、本地代码缓存等 分代假说 研究人员发现，Java对象的生命周期符合如下3个假说：\n弱分代假说（Weak Generational Hypothesis）：绝大多数对象是朝生夕灭的 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说是极少的 以上几个分代假说，奠定了多款常用的垃圾收集器的设计原则：\n收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。 在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，同时能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法。 跨代引用是极少的，因此没必要在新生代垃圾回收时扫描整个老年代，只需建立一个全局的数据结构 记忆集（Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。 清除算法 标记-清除 最基础的 GC 算法是「标记-清除」（Mark-Sweep）。分为「标记」、「清除」两个阶段。首先标记出所有需要回收的对象，然后统一回收。标记过程之前已经讲过了。\n如图：\n缺点：内存空间碎片化，如果无法给一个大对象分配足够空间，JVM 会提前触发 Full GC。\n标记-复制 标记-复制（mark-copying）算法将内存分为两块。若一块内存用毕，就对这块区域进行一次垃圾收集，将还存活的对象复制到另一块区域上。每次只使用一块，并将另一块内存保留。\n相较于标记-清除算法，标记-复制的算法的优点是不会产生碎片。但他的缺点也很明显：有额外的复制开销，并且内存利用率最多只有50%。\n回想一下分代假设：1. 大多数对象朝生夕灭；2. 熬过越多次 GC 的对象，越难以消亡。\n对于新生代中的对象，由于其朝生夕灭的特性，就非常适合 Mark-Copy 算法。\n现代JVM中，还对Mark-Copy进行了优化，将新生代分为较大的一块 Eden 和两块 Survivor。分配时使用 Eden 和一块 Survivor。GC 时，将 Eden 和其中一块 Survivor 内存区域中的存活对象，复制到另一块 Survivor 空间上。HotSpot VM 默认的比例为 Eden:Survivor=8:1 。也就是说，只有 10%的内存会被浪费（因为有两块 Survivor，最终比例是 8:1:1）。\n标记-整理 对于老年代，对象存活率较高，较多的复制操作会导致性能下降，此时就不适用标记-复制算法了。\n针对老年代特征，可以使用标记-整理（Mark-Compact）算法。其标记过程和\u0026quot;标记-清除\u0026quot;算法一样，但后续不是清理可回收对象，而是直接让所有存活对象都向一端移动，直接清理掉端边界外的内存。\n然而，移动存活对象的代价是很高的，尤其是老年代这种大区块。移动存活对象并更新引用是一项沉重、耗时的操作，必须停止整个程序 stop the world。 极大影响程序的响应速度。\n垃圾收集器 分代收集算法概念：根据对象的不同类型将内存划分为不同的区域，JVM将堆划分为新生代、老年代和永久代，并根据各个年代的特点分别采用不同的GC算法。\n这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。根据系统可接受的停顿时间，每次都快速回收若干个小区域，从而减少一次GC所产生的的停顿时间，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。\n分代 适用算法 特点 新生代 标记-复制算法 对象生命周期短，标记阶段会标记大量已死亡对象 老年代 标记-整理算法 生命周期长的对象、大对象，可回收数量少 永久代 回收废弃的常量、无用的类 存储Class类、常量、方法描述等 Serial收集器（新生代） 客户端模式下的默认新生代收集器； 简单而高效，额外的内存消耗最小； 可以管理较小内存（几十兆到一两百兆内存） Serial Old收集器（老年代） 单线程的老年代垃圾回收器。\nParallel Scavenge收集器（新生代） 新生代收集器； 基于标记–复制算法的收集器； 并行收集的多线程收集器； 可控制吞吐量的收集器。 这款垃圾回收器又被称为吞吐量优先收集器。适用于跑批应用，不用太在乎单次STW卡顿时间，只要能够尽可能得利用CPU资源跑完程序就好。\n$$ 吞吐量=\\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间} $$\n-XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间；该参数允许的值是一个大于 0 的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值；\n-XX:GCTimeRatio：直接设置吞吐量大小，该参数的值是一个大于 0 小于 100 的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为 19，那允许的最大垃圾收集时间就占总时间的 5%（即1/(1+19)），默认值为 99，即允许最大 1%（即1/(1+99)）的垃圾收集时间。\n-XX:+UseAdaptiveSizePolicy：开启自适应调节策略，当这个参数被激活之后，就不需要人工一些参数细节了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。\nParNew收集器（新生代） 多线程并行版的Serial新生代垃圾回收器。除了 Serial 收集器外，目前只有 ParNew 能与 CMS 收集器配合工作。\nParallel Old收集器（老年代） Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。\nCMS（ConcurrentMarkSweep）收集器（老年代） 比并发的老年代收集器Parallel Old又在进步一些，追求垃圾回收期间与用户程序并发、且低延迟，适合用在面向互联网用户的服务器应用。\n垃圾收集算法是标记-清除，清除不会造成STW，所以优化点是标记，用到前面讲到的办法将标记过程拆细，分为初始标记（卡顿）、并发标记（无需卡顿）、二次标记（卡顿），初始标记、二次标记虽然卡顿但时间都很短。\nCMS 垃圾收集四个步骤：\n初始标记（CMS initial mark）：Stop The World，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；\n并发标记（CMS concurrent mark）：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；\n重新标记（CMS remark）：Stop The World，重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；\n并发清除（CMS concurrent sweep）：并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\nCMS 垃圾收集器不足：\n1）虽然可以并发进行标记、清理减少卡顿，但是多线程并行会消耗机器资源导致用户程序变慢，吞吐量降低。\n使用这款垃圾回收器要注意CPU核数的选择：CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。**但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。**如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。\n2）CMS 垃圾收集器无法处理“浮动垃圾（Floating Garbage）\n跟其他垃圾回收器不一样，不能等到老年代满了才进行垃圾回收了，因为回收过程中与用户线程并发，用户线程会产生新的对象，因此有一个参数（-XX：CMSInitiatingOccupancyFraction）控制老年代占用内存比例到达多少时触发垃圾回收，默认值是92%。如果并发期间分配对象还是失败，就会触发一次兜底的Serial Old。\n3）基于标记–清除算法实现，会产生内存碎片。 -XX:+UseCMS-CompactAtFullCollection：在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程； -XX:CMSFullGCsBefore-Compaction：这个参数的作用是要求 CMS 收集器在执行过若干次（数量由参数值决定）不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。\n如果多次标记-清除，内存碎片太多无法找到足够大的连续空间分配对象，就会触发一次带内存碎片整理的Full GC（- XX：+ UseCMS-CompactAtFullCollection参数控制Full GC前是否需要内存整理，默认开启。\nG1收集器（混合代） 一个收集器就可以搞定整个内存的垃圾回收，不需要配置两个新生代和老年代的垃圾回收器了，因为内存布局跟原来完全不一样了，新生代和老年代粒度变小了，如下图，这种方式叫基于Region的内存布局，每个Region大小相等。\n这么设计有什么好处？\n和垃圾回收器G1（Garbage First）的命名相关，追求的目标是固定一个延迟时间，不再区分回收新生代还是老年代，而是回收价值最大（能够回收最多内存的的区域），Garbage First可以叫回收效益排名第一的垃圾回收器。\n关键参数- XX：MaxGCPauseMillis，默认值是200ms，核心的实现思路是建议停顿预测模型，即记录回收每个Region可能需要耗费的时间。\n每次回收的过程跟CMS差不多，不过用的是标记-复制。\n1）初始标记(Initial Marking)：会卡顿\n2）并发标记（Concurrent Marking）\n3）最终标记（Final Marking）：会卡顿\n4）筛选回收（Live Data Counting and Evacuation)：回收价值最高的Region，用复制算法，会卡顿\n启示和展望 在云原生浪潮席卷的今天，软件环境已经发生了天翻地覆的变化，不由让我们思考这样一个问题：我们是否还需要JVM? 我们是否真的还需要平台无关性？\n将在的Java JVM 和 浏览器的v8引擎 进行比较，可以很明显的发现，我们不再需要客户端了，也不再需要平台无关性了，服务端的一切我们都是可控的。在这种背景下，GraalVM应运而生。\nref 深入理解Java虚拟机 https://book.douban.com/subject/34907497/\njvm参数生成及工具指引 https://render.alipay.com/p/s/jvm-generate/JvmGenerate\njvm在线诊断 https://arthas.aliyun.com/\ngc日志在线分析 https://gceasy.io/\nhttps://www.yuque.com/belber/archive/bhgel2?#QWTJx\n","permalink":"https://Kazekumo.github.io/posts/thinking-jvm/","summary":"为什么有JVM 在学习JVM(Java Virtual Machine )之前，大家可以先思考一个问题，为什么我们需要JVM\n以上图为例，cpp开发的软件具备一个明显劣势，那就是他无法满足跨平台的需求(一次编写，处处编译)\n计算机领域有一句名言：\n计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.\nJVM便是通过增加中间层实现了一次编译，处处运行\nJVM能做什么 平台无关性: 通过class文件将程序和机器环境进行解耦，运行时再翻译成机器码 语言无关性: JVM不与Java等任何程序语言进行绑定，只要是符合标准的class文件都可以运行在JVM上 JVM运行机制 垃圾回收 除了上面的跨平台性，Java 和 cpp相比，还有一个显著的区别，那就是内存动态分配和垃圾回收。\n对于GC(Garbage Collection)，我们需要考虑2个问题：\n哪些内存需要回收? 如何回收? 程序计数器、虚拟机栈、本地方法栈 3 个区域是 Thread Local 的，随线程而生，随线程而灭，自然也不用过多关心如何回收的问题。\n然而 Heap 和方法区有显著的不确定性，这部分内存更是实际中用得最多的内存，也因此诞生了许多分配与回收算法。\n引用计数 引用记数（Reference Counting）是最简单的一种收集方法，许多编程语言使用该方法管理内存（Objective-C、Swift 等）\n它的缺点和优势都很明显。它的判定效率高，占用低。然而仍然需要程序员在编码时额外配合，必须手动将对象置空。\n除此之外，它无法解决循环引用问题。\n可达性分析 当一块内存永远不可能再被访问到时，他就应该被回收。\n如图所示，该算法的主要思路是把一系列被称作「GC Roots」的根对象作为起始节点，从这些节点开始往下搜索，搜索过的路径称作「引用链」（Reference Chain）。如果某个对象和 GC Roots 间没有引用链连接。就说明该对象不可达，也就不可能再被使用。\n在 JVM 中，可作为 GC Roots 的对象有以下几种：\nVM Stack 中引用的对象，如方法参数、局部变量、临时变量等。 在方法区内的静态属性对象 在方法去内常量引用的对象，如字符串常量池（String Table）中的引用 本地方法栈中 JNI 引用的对象 JVM 内部引用，如基本数据类型对应的 Class 对象，一些长驻的异常对象（NPE OOM 等），以及类加载器。 所有被同步锁（synchronized 关键字）持有的对象 JMXBean、JVMTI 中的回调、本地代码缓存等 分代假说 研究人员发现，Java对象的生命周期符合如下3个假说：","title":"JVM笔记"},{"content":"开发中发现许多对象都依赖了css的基类对象BaseEntity 偶然点开发现里面的写法不太容易理解，因此分析记录一下\n点开对象可以发现，有两个属性是比较特别的，也就是 propMap 和 visitor 本文的目的也主要是分析这两个对象的用途。\n先直接看这两个对象在哪用了，翻阅源码可以发现，两个属性的主要使用入口都在toString中。 最终这个函数是调用了toString0 或者 hexString 初见这一坨，我也百思不得其解，先不管，继续看看toString0 分析代码可知，toString0这个方法才是对象转字符串的主要实现，通过getProps获取对象的属性列表，然后在下面进行属性的拼接 看看getProps，可以发现propMap的用途是存储该类的所有属性名称。 如果该对象的属性未初始化，则通过反射获取。 需要注意的是，这里使用了 double check lock，避免重入。 当第二次进入时，就可以复用属性，不用再反射获取了。 到了此处，propMap 的用途基本就解答了。\n那么为啥要有 visotor 呢？我们再回过头来看toString方法 在toString方法中，visitor 的逻辑主要如下\n如果 visitor为空，重新初始化 visitor 如果 visitor.get() 为空： 1. 设置 visitor 为当前对象 2. 调用 toString0 3. 设置 visitor 为 null 如果 visitor 的值不为空，返回 HexString 这里的目的不太好理解。首先对于步骤1，我们可以先忽略，因为实际不影响流程。 控制流程的主要是步骤2和步骤3。 首先可以观察到，步骤2的进入条件是 visitor 为空，步骤3的进入条件为 visitor 不为空。也就是说，步骤2和步骤3这两步操作是互斥的。 在步骤2.1中，设置了 visitor 为当前对象，然后在2.3中又重置了回去。那么也就是说同一个线程，他不能重入步骤2。\n这里比较有迷惑性，因为threadLocal是线程独立的，搞这么复杂干嘛呢，同一个线程还能重入这个方法不成？ 读者可以先思考一下，表情包下面给出答案。\n同一个线程还能重入这个方法不成？确实是可能的。 答案就是当对象发生了循环引用，这时调用toString方法，序列化子对象时，由于循环引用，就会再次进入父对象的toString方法，不断套娃，最终导致栈溢出。 所以此处使用visitor进行流程控制的目的就是为了打破这个循环调用链。\n实际上，许多框架都支持了循环引用，不过方式上可能有些许差异，比如 FastJson 使用 $ref 占位符避免序列化子对象，Spring 使用了多级缓存的方式等等，这里就不赘述了。\n框架开发人员总是考虑到各种场景进行了兼容，不过我认为大部分循环引用，其实并不值得解决，因为其代表是层级结构本身的不合理。\n","permalink":"https://Kazekumo.github.io/posts/baseentity-analysis/","summary":"开发中发现许多对象都依赖了css的基类对象BaseEntity 偶然点开发现里面的写法不太容易理解，因此分析记录一下\n点开对象可以发现，有两个属性是比较特别的，也就是 propMap 和 visitor 本文的目的也主要是分析这两个对象的用途。\n先直接看这两个对象在哪用了，翻阅源码可以发现，两个属性的主要使用入口都在toString中。 最终这个函数是调用了toString0 或者 hexString 初见这一坨，我也百思不得其解，先不管，继续看看toString0 分析代码可知，toString0这个方法才是对象转字符串的主要实现，通过getProps获取对象的属性列表，然后在下面进行属性的拼接 看看getProps，可以发现propMap的用途是存储该类的所有属性名称。 如果该对象的属性未初始化，则通过反射获取。 需要注意的是，这里使用了 double check lock，避免重入。 当第二次进入时，就可以复用属性，不用再反射获取了。 到了此处，propMap 的用途基本就解答了。\n那么为啥要有 visotor 呢？我们再回过头来看toString方法 在toString方法中，visitor 的逻辑主要如下\n如果 visitor为空，重新初始化 visitor 如果 visitor.get() 为空： 1. 设置 visitor 为当前对象 2. 调用 toString0 3. 设置 visitor 为 null 如果 visitor 的值不为空，返回 HexString 这里的目的不太好理解。首先对于步骤1，我们可以先忽略，因为实际不影响流程。 控制流程的主要是步骤2和步骤3。 首先可以观察到，步骤2的进入条件是 visitor 为空，步骤3的进入条件为 visitor 不为空。也就是说，步骤2和步骤3这两步操作是互斥的。 在步骤2.1中，设置了 visitor 为当前对象，然后在2.3中又重置了回去。那么也就是说同一个线程，他不能重入步骤2。\n这里比较有迷惑性，因为threadLocal是线程独立的，搞这么复杂干嘛呢，同一个线程还能重入这个方法不成？ 读者可以先思考一下，表情包下面给出答案。\n同一个线程还能重入这个方法不成？确实是可能的。 答案就是当对象发生了循环引用，这时调用toString方法，序列化子对象时，由于循环引用，就会再次进入父对象的toString方法，不断套娃，最终导致栈溢出。 所以此处使用visitor进行流程控制的目的就是为了打破这个循环调用链。\n实际上，许多框架都支持了循环引用，不过方式上可能有些许差异，比如 FastJson 使用 $ref 占位符避免序列化子对象，Spring 使用了多级缓存的方式等等，这里就不赘述了。","title":"某基类的源码分析"}]