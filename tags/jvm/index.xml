<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>jvm on Kazekumo&#39;s blog</title>
    <link>https://Kazekumo.github.io/tags/jvm/</link>
    <description>Recent content in jvm on Kazekumo&#39;s blog</description>
    <image>
      <title>Kazekumo&#39;s blog</title>
      <url>https://Kazekumo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://Kazekumo.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 15 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://Kazekumo.github.io/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JVM笔记01</title>
      <link>https://Kazekumo.github.io/posts/thinking-jvm-01/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://Kazekumo.github.io/posts/thinking-jvm-01/</guid>
      <description>为什么有JVM 在学习JVM之前，大家可以先思考一个问题，为什么我们需要JVM
以上图为例，cpp开发的软件具备一个明显劣势，那就是他无法满足跨平台的需求(一次编写，处处编译)
计算机领域有一句名言：
计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决.
JVM便是通过增加中间层实现了 一次编译，处处运行
JVM能做什么 平台无关性 语言无关性 JVM运行机制 垃圾回收算法 除了上面的跨平台性，Java 和 cpp相比，还有一个显著的区别，那就是内存动态分配和垃圾回收。
对于GC，我们需要考虑2个问题：
哪些内存需要回收? 如何回收? 程序计数器、虚拟机栈、本地方法栈 3 个区域是 Thread Local 的，随线程而生，随线程而灭，自然也不用过多关心如何回收的问题。
然而 Heap 和方法区有显著的不确定性，这部分内存更是实际中用得最多的内存，也因此诞生了许多分配与回收算法。
引用计数 引用记数（Reference Counting）是最简单的一种收集方法，许多编程语言使用该方法管理内存（Objective-C、Swift 等）
它的缺点和优势都很明显。它的判定效率高，占用低。然而仍然需要程序员在编码时额外配合，必须手动将对象置空。
除此之外，它无法解决循环引用问题。
可达性分析 当一块内存永远不可能再被访问到时，他就应该回收
如图所示，该算法的主要思路是把一系列被称作「GC Roots」的根对象作为起始节点，从这些节点开始往下搜索，搜索过的路径称作「引用链」（Reference Chain）。如果某个对象和 GC Roots 间没有引用链连接。就说明该对象不可达，也就不可能再被使用。
在 JVM 中，可作为 GC Roots 的对象有以下几种：
VM Stack 中引用的对象，如方法参数、局部变量、临时变量等。 在方法区内的静态属性对象 在方法去内常量引用的对象，如字符串常量池（String Table）中的引用 本地方法栈中 JNI 引用的对象 JVM 内部引用，如基本数据类型对应的 Class 对象，一些长驻的异常对象（NPE OOM 等），以及类加载器。 所有被同步锁（synchronized 关键字）持有的对象 JMXBean、JVMTI 中的回调、本地代码缓存等 垃圾回收算法 分代收集（Generational Collection）理论是最广泛应用的垃圾收集理论，建立在两个分代假说之上：
弱分代假说（Weak Generational Hypothesis）：大多数对象朝生夕灭 强分代假说（Strong Generational Hypothesis）：熬过越多次 GC 的对象，越难以消亡 因此，很容易想到将内存划分为多个区域，针对不同区域的特点，优化收集算法。很多 JVM GC 就是这么做的。</description>
    </item>
    
  </channel>
</rss>
